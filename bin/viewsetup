#!/usr/bin/python

import argparse
import json
import os
import re
import subprocess

from collections import defaultdict

KiB = 2 ** 10
MiB = 2 ** 20
GiB = 2 ** 30

allowed_actions = ['create-mapping', 'create-md', 'create-vmdk', 'list', 'remove', 'all']

parser = argparse.ArgumentParser('setup a view of a disk')
parser.add_argument('--action', '--actions', default='create-md',
                    help='comma-separated actions to perform, from: ' + ' '.join(allowed_actions))
parser.add_argument('--map', action='store_const', dest='action', const='create-mapping',
                    help='alias for --action=create-mapping')
parser.add_argument('--vmdk', action='store_const', dest='action', const='create-vmdk',
                    help='alias for --action=create-vmdk')
parser.add_argument('--device', '-d', default='/dev/nvme0n1',
                    help='(whole) disk to create a view of')
parser.add_argument('--basename', '-b', default=None,
                    help='name to use in generated files, defaults to basename of device')
parser.add_argument('--dir', '-o', default=None,
                    help='directory storing view configuration files')
parser.add_argument('--force', '-f', action='store_true', default=False,
                    help='overwrite existing files')
parser.add_argument('--auto', '-a', action='store_true', default=False,
                    help='choose default disposition for all partitions')

args = parser.parse_args()
md = None

actions = set(args.action.split(','))
for action in actions:
    if action not in set(allowed_actions):
        raise Exception(f"invalid action '{action}'")

if args.dir is None:
    if args.basename is None:
        args.basename = os.path.basename(args.device)
    args.dir = f'views/{args.basename}'


def run(cmd, quiet=False):
    if not quiet:
        print(" ".join(cmd))
    return subprocess.check_call(cmd)


def abort(msg):
    import sys
    print(msg, file=sys.stderr)
    sys.exit(1)


def read_mtab():
    mounts = {}
    with open("/etc/mtab", "rt") as fh:
        for line in fh.readlines():
            device, mountpoint, fstype, flags, n1, n2 = line.rstrip().split(" ")
            if device == fstype:
                continue  # Does not use a device eg proc
            mounts[device] = {
                'mountpoint': mountpoint,
                'fstype': fstype,
                'flags': set(flags.split(','))
            }
    return mounts


def read_partitions(device):
    mounts = read_mtab()
    info = defaultdict(dict)
    fdisk = json.loads(subprocess.check_output(["sudo", "sfdisk", "-J", device], text=True))
    info['unit'] = fdisk['partitiontable']['unit']
    if info['unit'] != 'sectors':
        raise Exception(f"script only handles units of sectors, not {info['unit']}")
    info['sector-size'] = fdisk['partitiontable']['sectorsize']
    for p in fdisk['partitiontable']['partitions']:
        part = {
            'device': p['node'],
            'start': p['start'],
            'size': p['size'],
            'end': p['start'] + p['size'],
            'gptname': p.get('name'),
            # FIXME: Have not looked at example with multiple attributes.
            'attrs': set(p.get('attrs', '').split(',')),
            'mount': mounts.get(p['node']),
        }
        info['partitions'][p['node']] = part

    for line in subprocess.check_output(["sudo", "sfdisk", "-l", device], text=True).splitlines():
        if m := re.match(r'(/dev/\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+)\s*(.*)', line):
            dev, start, end, sectors, size, type_ = m.groups()
            info['partitions'][dev]['type'] = type_

    info['end'] = int(subprocess.check_output(['sudo', 'blockdev', '--getsz', device], text=True).rstrip())
    
    info['ordered-partitions'] = sorted(
        info['partitions'].keys(),
        key=lambda k: info['partitions'][k]['start']
    )
    
    return info

slices_filename = os.path.join(args.dir, f"slices.txt")


def check_new_file(filename):
    if os.path.exists(filename) and not args.force:
        raise Exception(f"{filename} already exists, use -f (--force) to overwrite")


def copy_chunk(src, dst, offset, count, blocksize):
    check_new_file(dst)
    run([
        'sudo',
        'dd',
        f"if={src}",
        f"of={dst}",
        f"bs={blocksize}",
        f"count={count}",
        f"skip={offset}",
        'conv=sparse',
    ])


def human_bytes(b):
    if b < 4000:
        return f"{b} bytes"
    b = b / 1024
    if b < 4000:
        return f"{b:.1f} KB"
    b = b / 1024
    if b < 4000:
        return f"{b:.1f} MB"
    b = b / 1024
    if b < 4000:
        return f"{b:.1f} GB"
    b = b / 1024
    return f"{b:.1f} TB"


def is_windows_system_partition(part):
    gpt_types = set([
        "efi system partition",
        "microsoft reserved partition",
    ])
    if (part['gptname'] or '').lower() in gpt_types:
        return True

    if (part['gptname'] or '').lower() == 'basic data partition':
        if 'RequiredPartition' in part.get('attrs', set()):
            return True

    return False


def guess_disposition(part):
    if is_windows_system_partition(part):
        return ('clone', f"small Windows system partition")

    mount = part.get('mount')
    if mount and mount['mountpoint'].startswith('/boot'):
        return ('clone', f"cloned {mount['mountpoint']} partition")

    if mount:
        return ('mask', f"mounted partition, mask with zeroes")

    if 'microsoft' in part.get('type', '').lower():
        return ('expose', f"Windows or other partition to expose")

    if 'lvm' in part.get('type', '').lower():
        return ('mask', f"LVM partition, masking it off")

    if part.get('gptname'):
        return ('expose', f"assumed to be Windows or system partition to expose")

    return ('mask', f"other partition to mask with zeroes")


def make_zeroes(dst, count, blocksize):
    check_new_file(dst)
    run([
        'sudo',
        'dd',
        f"if=/dev/zero",
        f"of={dst}",
        f"bs={blocksize}",
        f"count=0",
        f"seek={count}",
        'conv=sparse',
    ])


def describe(names):
    names = [os.path.basename(n) for n in names]

    # If there is a device and its partitions, tack the partition indicators
    # onto the device (eg /dev/nvme0n1,/dev/nvme0n1p1,/dev/nvme0n1p2 ->
    # /dev/nvme0n1p1p2).
    shortest = sorted(names, key=lambda s: len(s))[0]
    if m := re.search(r'(p\d+)$', shortest):
        shortest = shortest[0:-len(m.group(1))]
    parts = []
    for name in names:
        if name == shortest:
            # Just drop the main device; it'll be a gap.
            continue
        if not name.startswith(shortest):
            parts = None
            break
        rest = name[len(shortest):]
        if re.search(r'p\d+$', rest):
            parts.append(rest)
    if parts is not None:
        return shortest + "".join(parts)
    else:
        return ",".join(names)

if 'create-mapping' in actions or 'all' in actions:
    info = read_partitions(args.device)
    maskid = [0]

    def process_range(slices):
        disposition = slices[0]['disposition']

        if disposition != 'expose':
            sectors = slices[-1]['end'] - slices[0]['start']
            if sectors % (4096 / info['sector-size']):
                import pdb; pdb.set_trace()
                devices = " ".join(i['device'] for i in slices)
                print(f"alignment error for devices {devices}")
                abort(f"{sectors} will get mangled with mdadm rounding. Time to learn about dmsetup linear?")

        if disposition == 'mask':
            filename = os.path.join(args.dir, f"{args.basename}.zero{maskid[0]}.dat")
            maskid[0] += 1
            make_zeroes(filename, slices[-1]['end'] - slices[0]['start'], info['sector-size'])
            slices[0]['filename'] = filename

        elif disposition in ('clone', 'gap'):
            name = describe([slice['device'] for slice in slices])
            filename = os.path.join(args.dir, f"{args.basename}.{name}.dat")
            sectors = slices[-1]['end'] - slices[0]['start']
            copy_chunk(args.device, filename, slices[0]['start'], sectors, info['sector-size'])
            slices[0]['filename'] = filename

        else:
            assert disposition == 'expose'
            slices[0]['filename'] = slices[0]['device']


    def make_files_for_slices(slices):
        # Merge consecutive slices with the same non-expose disposition.
        range = [slices[0]]
        for slice in slices[1:]:
            disposition = slice['disposition']
            if range[0]['disposition'] == disposition and disposition != 'expose':
                range.append(slice)
            elif slice['disposition'] == 'gap' and range[-1]['disposition']:
                # Attach gap to previous range.
                range.append(slice)
            else:
                process_range(range)
                range = [slice]
        if range:
            process_range(range)

    os.makedirs(args.dir, exist_ok=True)
    check_new_file(slices_filename)

    mounts = read_mtab()
    slices = []
    prev_end = 0
    for device in info['ordered-partitions']:
        part = info['partitions'][device]
        disposition, why = guess_disposition(part)

        print(f"{device}:")
        if mounts.get(device):
            print(f"  {mounts[device]['fstype']} filesystem mounted at {mounts[device]['mountpoint']}")
        print(f"  sectors {part['start']}-{part['end']-1}, {human_bytes(part['size'] * info['sector-size'])}")
        print(f"  GPT partition name: {part['gptname']}")
        if args.auto:
            print(f"  automatically chosen disposition is {disposition}: \"{why}\"")
        else:
            print(f"  default disposition is {disposition}: \"{why}\"")
        while not args.auto:
            answer = input(f"disposition (one of expose, mask, clone) (default {disposition})> ")
            if answer != "":
                if answer in ('expose', 'mask', 'clone'):
                    disposition = answer
                    break
                else:
                    print("invalid disposition")
            else:
                break
        print()

        gap = part['start'] - prev_end
        if gap > 0:
            slices.append({
                'disposition': 'gap',
                'description': 'gap between partitions',
                'device': args.device,
                'sectors': gap,
                'bytes': gap * info['sector-size'],
                'start': prev_end,
                'end': part['start'],
                'type': 'file'
            })

        slices.append({
            'disposition': disposition,
            'device': device,
            'sectors': part['size'],
            'bytes': part['size'] * info['sector-size'],
            'start': part['start'],
            'end': part['end'],
        })

        if disposition == 'expose':
            slices[-1].update({
                'description': f"exposed partition {device}",
                'device': device,
                'type': 'partition',
            })
        elif disposition == 'mask':
            slices[-1].update({
                'description': f"masked-off partition {device}",
                'type': 'file',
            })
        elif disposition == 'clone':
            slices[-1].update({
                'description': f"partition {device} cloned to a file",
                'type': 'file',
            })
        else:
            raise Exception(f"unknown disposition '{disposition}'")

        prev_end = part['end']

    gap = info['end'] - slices[-1]['end']
    if gap > 0:
        slices.append({
            'disposition': 'gap',
            'description': 'gap after last partition',
            'device': args.device,
            'sectors': gap,
            'bytes': gap * info['sector-size'],
            'start': slices[-1]['end'],
            'end': info['end'],
            'type': 'file'
        })

    make_files_for_slices(slices)

    with open(slices_filename, "w") as fh:
        fh.write(json.dumps(slices, indent=4))

if 'create-md' in actions or 'all' in actions:
    with open(slices_filename, 'r') as fh:
        slices = json.load(fh)
    for slice in slices:
        if slice['type'] == 'file' and slice['filename']:
            slice['loopback'] = subprocess.check_output([
                'sudo',
                'losetup',
                '-f',
                '--show',
                slice['filename']
            ], text=True).rstrip()

    md = 0
    while os.path.exists(f"/dev/md{md}"):
        md += 1
    run([
        'sudo',
        'mdadm',
        '--build',
        f"/dev/md{md}",
        '--level=linear',
        '--rounding=4',
        f"--raid-devices={len(slices)}"
    ] + [s.get('loopback') or s['filename'] for s in slices])

    user = subprocess.check_output(['id', '-nu'], text=True).rstrip()
    group = subprocess.check_output(['id', '-ng'], text=True).rstrip()
    run(['sudo', 'chown', f"{user}:{group}", f"/dev/md{md}"])
    run(['sudo', 'chmod', '0666', f"/dev/md{md}"])

if md is None:
    # Find the last /dev/md{n} device, assuming it's the one created
    # by this script.
    md = 0
    while os.path.exists(f"/dev/md{md}"):
        md += 1
    if md == 0:
        md = None
    else:
        md -= 1
    
if 'create-vmdk' in actions or 'all' in actions:
    vmdk_filename = os.path.join(args.dir, f"{args.basename}.vmdk")
    run(['VBoxManage', 'internalcommands', 'createrawvmdk', '-filename', vmdk_filename, '-rawdisk', f"/dev/md{md}"])

def get_devices(mdfile):
    devices = []
    active = 0
    for line in subprocess.check_output(['sudo', 'mdadm', '--detail', f"/dev/md{md}"], text=True).splitlines():
        if m := re.match(r'^\s*Number', line):
            active = 1
        elif active:
            devices.append(line.split(" ")[-1])
    return devices

   
if 'list' in actions or 'all' in actions:
    if md is None:
        raise Exception("no /dev/md* devices found")
    for device in get_devices(f"/dev/md{md}"):
        if device.startswith('/dev/loop'):
            run(['losetup', device], quiet=True)
        else:
            print(device)
    
if 'remove' in actions:
    if md is None:
        raise Exception("no /dev/md* devices found")
    devices = get_devices(f"/dev/md{md}")
    run(['sudo', 'mdadm', '--remove', f"/dev/md{md}"])
    run(['sudo', 'mdadm', '--stop', f"/dev/md{md}"])
    with open(slices_filename, 'r') as fh:
        slices = json.load(fh)
    for device in devices:
        if device.startswith('/dev/loop'):
            run(['sudo', 'losetup', '-d', device])
