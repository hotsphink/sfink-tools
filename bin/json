#!/usr/bin/perl

use JSON;
use File::Basename qw(dirname basename);
use Term::ReadLine;
use Getopt::Long;
use strict;
use warnings;

my $json = JSON->new->utf8->relaxed;
my $pjson = JSON->new->utf8->relaxed->canonical->pretty;

$SIG{__WARN__} = sub { print(@_); $DB::single = $DB::single = 1; };

sub help {
    my ($opts) = @_;

    if ($opts->{error}) {
        print STDERR $opts->{error}, "\n";
    }

    print <<'END';
Usage: json <filename.json> [initial-path] [-e COMMAND]

    ls [PATH]              - show contents of structure
    cd PATH                - change current view to PATH
    cat [--nokeys] [PATH]  - display the value at the given PATH
    delete SPEC            - delete the given key or range of keys (see below
                             for a description of SPEC)
    set KEY VALUE          - modify an existing value (VALUE may optionally
                             be quoted)
    transform PATH EXPR    - for every value VSRC found at PATH, convert EXPR
                             to a new value by processing substitutions. Replacements:
        {basename}
        {dir}
        {path}
        $(pathexpr)
        $eval(expr)
        $sum(expr)
                             Example: transform markers/name/* $(stringArray/{basename})
    grep -e 'EXPR' PATTERN PATH
                             - for every value found at PATH matching PATTERN, print out
                             the value of EXPR evaluated in the context of the matching path.
    grep [OPTIONS] PATTERN PATH
                             - search for PATTERN in given PATH. By default, prints out
                               leaf values found.
        -l                     - display container of each leaf found instead of leaf
        -c                     - count occurrences of items found and display histogram
        --cd                   - chdir to the single item found
        --dir                  - search all keys instead of leaves
        --all                  - search keys and leaves
        --size                 - display size of item along with item
        --delete               - delete matching items
    groupby PATH EXPR GROUPEXPR
    group PATH EXPR by GROUPEXPR
                           - for every item matching PATH, report the result of EXPR grouped
                             by GROUPEXPR. Example:
                             groupby markers/data/*/nursery '$sum(phase_times/Total)' 'reason'
    sum PATH               - print the sum of the hopefully numeric items found at PATH
    mv PATH PATH           - move a subtree
    mmv PATTERN PATH DEST  - move all immediate children in PATH matching
                             PATTERN to DEST
    write [--pretty|--noindent] [FILENAME]
                           - write out the whole structure as JSON. Use '-' as
                             FILENAME to write to stdout.
    pretty                 - prettyprint current structure to stdout
    size PATH              - display how many bytes the JSON of the substructure
                             at PATH would take up
    load [FILENAME]        - load in the given JSON file (reload current file
                             if no filename given)
    export FILENAME        - write the current subtree into the given file
    import FILENAME [DEST] - imports the given JSON file into the current location
                             (under the key DEST, if given)
    quit                   - exit this program
    help                   - show this message

Paths:

    PATHs are slash-separated sequences of key names, '.', '..', '*', or '**'.
    '**' means a recursive search.

Delete Specifications:

    A delete SPEC can be a plain key name, or a range of the format 'M..N',
    where one of M and N may be optional. M defaults to zero. N defaults to the
    highest index available. Ranges are inclusive.
END

    exit 1 if $opts->{error};
    exit 0 if $opts->{exit};
}

my @inputbuffer;

# Fix bizarre readline bug where it spews some crap into stdout on shutdown.
# My attempts to fix it via $term->variable_bind("enable-meta-key", "off")
# and similar did not work.
if (defined $ENV{TERM}) {
    $ENV{TERM} =~ s/xterm-256color/vt100/;
}

my $term = Term::ReadLine->new("JSON explorer");
our $oldout = select($term->OUT || \*STDOUT) if (-t STDOUT);
END { select($oldout) if $oldout; }
my $attribs = $term->Attribs;

my $MAX = 10;
my $struct;
my $dirty = 0;
my $current;
my @current;
my $batch;
my $verbose;

GetOptions("h|help!" => sub { help({ exit => 1 }) },
           "e|command=s" => \@inputbuffer,
           "v|verbose!" => \$verbose,
           "i|interactive!" => sub { $batch = 0 })
    or help({ error => 'invalid arguments' });

if ((! -t STDIN) && (@ARGV == 0)) {
    @ARGV = ('-');
}
help({error => 'not enough arguments'}) if @ARGV == 0;

$batch = 1 if !defined($batch) && @inputbuffer;

my $current_file = shift(@ARGV);

load();

# TODO: Add in quoting etc. here and in strpath.
sub parse_path {
    my ($path_str, $default) = @_;
    die if ref $path_str;

    if (! defined $path_str) {
        return [$default] if defined $default;
        return [];
    }

    return ['/'] if $path_str eq '/';

    my $path = [ split(/\//, $path_str) ];
    $path->[0] = '/' if $path->[0] eq '';
    return $path;
}

sub strpath {
    my ($path, $suffix) = @_;
    my $str;
    if (@$path && $path->[0] eq '/') {
        $str = join("/", '', @{ shiftpath($path) });
    } else {
        $str = join("/", @$path);
    }
    return $str . ($suffix // '');
}

sub dirpath {
    my ($path) = @_;
    my @dirpath = @$path;
    pop @dirpath;
    return \@dirpath;
}

sub joinpath {
    my ($path, $component) = @_;

    return $component if ! defined $path;
    return $path if ! defined $component;

    my @path = ref $path ? @$path : ($path);
    my @component = ref $component ? @$component : ($component);

    return [ @path, @component ];
}

sub shiftpath {
    my ($path) = @_;
    my @path = @$path;
    shift(@path);
    return \@path;
}

sub splitpath {
    my ($path) = @_;
    my @path = @$path;
    my $base = pop(@path);
    return \@path, $base;
}

if (@ARGV) {
    my $init_path = parse_path(shift(@ARGV));
    chpath($init_path)
        or die "No path '" . strpath($init_path) . "' found, exiting.\n";
}

if (!$batch && ! -t STDIN) {
    prettyprint($current->[-1]);
    exit 0;
}

my @completions;
my $c_i;
sub completion {
    my ($text, $generating) = @_;

    $attribs->{filename_completion_desired} = 1;
    $attribs->{filename_quoting_desired} = 1;

    if (!$generating) {
        if ($text =~ m!(.*)/[^/]*$!) {
            my ($complete, $prefix) = ($1, $2);
            my $stack = enterPath($current, parse_path($complete), 1);
            if ($stack) {
                @completions = map { "$complete/$_" } get_completions($stack->[-1]);
            } else {
                @completions = ();
            }
        } else {
            @completions = get_completions($current->[-1]);
        }
    }

    $c_i = $generating ? $c_i + 1 : 0;
    for (; $c_i < @completions; $c_i++) {
        my $option = $completions[$c_i];
        if (index($option, $text) == 0) {
            $attribs->{completion_append_character} =
                ($option =~ m!/$! ? "\0" : " ");
            return $option;
        }
    }
    return undef;
}
$attribs->{completion_entry_function} = \&completion;
$attribs->{completer_word_word_break_characters} .= "/";
$attribs->{completer_quote_characters} = "'";
$attribs->{filename_quote_characters} = "'";

sub entry_str {
    my ($obj, $key) = @_;
    my $str = $key;
#    if ($key =~ m!/!) {
#        $str = "'$str'";
#    }

    my $entry = enter($obj, $key, 1);
    $str .= "/" if defined($entry) && ref($entry);
    $str .= "?" if !defined($entry);
    return $str;
}

sub get_completions {
    my ($obj) = @_;
    #return map { entry_str($obj, $_) } all_keys($obj);
    return all_keys($obj);
}

sub nextcommand {
    my ($prompt) = @_;
    return shift(@inputbuffer) if @inputbuffer;
    return if $batch;
    return $term->readline("$prompt> ");
}

LS: while(1) {
    cmd_ls($current) unless $batch;

    while (1) {
        my $prompt = shortjoin(50, @current[1..$#current]);
        my $input = nextcommand($prompt);
        if (! defined $input) {
            quit();
            next;
        }
        chomp($input);
        $term->addhistory($input) if $input =~ /\S/;

        $input =~ s/\s+$//;
        if ($input eq 'help') {
            help();
        } elsif ($input =~ /^cd (.*?)$/) {
            next LS if chpath(parse_path($1));
        } elsif ($input =~ /^cat$/) {
            cmd_cat($current);
        } elsif ($input =~ /^cat (--nokeys )?([^>]*?)\s*(?:\>\s*(\S+))?$/) {
            cmd_cat($current, $1, $2, $3);
        } elsif ($input =~ /^ls$/) {
            next LS;
        } elsif ($input =~ /^ls (.*?)$/) {
            cmd_ls($current, $1);
        } elsif ($input =~ /^limit (\d+)$/) {
            $MAX = $1;
        } elsif ($input =~ /^delete (.*?)$/) {
            cmd_delete_keys($current, $1);
        } elsif ($input =~ /^set (\S+)[\s=]+(.*)$/) {
            set_value($current->[-1], $1, $2);
        } elsif ($input =~ /^transform (-d \S+ )?(\S+)( -d \S+)?\s+(.*)$/) {
            cmd_transform($current, $2, $4, $1 || $3);
        } elsif ($input =~ /^push (.*)$/) {
            push_value($current->[-1], $1);
        } elsif ($input =~ /^unshift (.*)$/) {
            unshift_value($current->[-1], $1);
        } elsif ($input =~ /^mv (\S+) (\S+)$/) {
            cmd_mv($current, $1, $2);
        } elsif ($input =~ /^sum (\S+)$/) {
            cmd_sum($current, $1);
        } elsif ($input =~ /^grep -e '(.*?)' ("[^"]*"|'[^']*'|\S+) (\S+)$/) {
            cmd_search($current, $2, $3, undef, $1);
        } elsif ($input =~ /^grep ((?:-[\w-]+ )*)("[^"]*"|'[^']*'|\S+) (\S+)$/) {
            cmd_search($current, $2, $3, $1);
        } elsif ($input =~ /^groupby ('.*?'|\S+) ('.*?'|\S+) ('.*?'|\S+)$/) {
            cmd_groupby($current, $1, $2, $3);
        } elsif ($input =~ /^group ('.*?'|\S+) ('.*?'|\S+) by ('.*?'|\S+)$/) {
            cmd_groupby($current, $1, $2, $3);
        } elsif ($input =~ /^mmv (.*) (\S+) (\S+)$/) {
            cmd_movegroup($current, $1, $2, $3);
        } elsif ($input =~ /^write (?:(--\w+)\s*)?(.*?)$/) {
            write_file($2, $1);
        } elsif ($input =~ /^write(?: (--\w+))?$/) {
            write_file($ARGV[0], $2);
        } elsif ($input =~ /^pretty$/) {
            prettyprint($current->[-1]);
        } elsif ($input =~ /^load (.*?)$/) {
            load($1);
        } elsif ($input =~ /^(load|reload)$/) {
            load();
        } elsif ($input =~ /^import (\S+)(?: (.*))?$/) {
            cmd_import($current, $current->[-1], $1, $2);
        } elsif ($input =~ /^export (.*?)$/) {
            cmd_export($current, $current->[-1], $1);
        } elsif ($input =~ /^size (.*?)$/) {
            cmd_show_size($current, $1);
        } elsif ($input =~ /^size$/) {
            cmd_show_size($current);
        } elsif ($input =~ /^quit$/) {
            quit();
        } else {
            print "Unrecognized command\n";
        }
    }
}

sub load {
    my ($file) = @_;
    $file //= $current_file;
    use IO::Zlib;
    # Sadly, IO::Zlib ignores $/ so there's no good way to slurp a file.
    my $data = do {
        local $/; # Maybe someday...
        my $fh = IO::Zlib->new($file, 'r') or die "open $file: $!";
        join('', $fh->getlines)
    };
    eval {
        $struct = $json->decode($data);
    };
    if ($@) {
        print "Failed to parse JSON text: $@";
        open(my $F, ">", "/tmp/shit.json");
        print $F $data;
        close($F);
        die $@;
    }
    $current = [ $struct ];
    @current = ( "[top]" );
    $current_file = $file;
    $dirty = 0;
}

sub cmd_export {
    my ($current, $struct, $file) = @_;

    open(my $fh, ">", $file) or die "create $file: $!";
    my $json = $pjson->utf8->canonical;
    print $fh $json->encode($struct)
        or die "writing to $file: $!";
}

sub cmd_import {
    my ($current, $struct, $file, $dest) = @_;
    my $data = do { local $/; open(my $fh, "<", $file) or die "open $file: $!"; <$fh> };
    my $value = $json->decode($data);
    if (defined $dest) {
        if (UNIVERSAL::isa($struct, 'HASH')) {
            $struct->{$dest} = $value;
        } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
            $struct->[$dest] = $value;
        } else {
            print "At a leaf node\n";
        }
    } else {
        if (UNIVERSAL::isa($struct, 'HASH')) {
            if (UNIVERSAL::isa($value, 'HASH')) {
                $struct->{$_} = $value->{$_} foreach keys %$value;
            } else {
                print "Mismatched types\n";
            }
        } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
            if (UNIVERSAL::isa($value, 'HASH')) {
                push @$struct, $value;
            } else {
                push @$struct, @$value;
            }
        }
    }

    $dirty = 1;
}

sub prettyprint {
    my ($struct) = @_;
    print $pjson->encode($struct);
}

sub write_file {
    my ($filename, $arg) = @_;
    $filename ||= $current_file;
    $arg ||= '';

    my $fh = ($filename eq '-') ? \*STDOUT : IO::File->new("> $filename.tmp")
        or die "create $filename.tmp: $!";

    my $json = $json->utf8; #->canonical;
    $json = $pjson if $arg;
    my $out = $json->encode($struct);
    $out =~ s/^\s+//mg if $arg eq '--noindent';
    print $fh $out
        or die "writing to $filename.tmp: $!";

    return if $filename eq '-';

    close($fh)
        or die "closing $filename.tmp: $!";
    if (rename($filename, "$filename.bak")) {
        rename("$filename.tmp", $filename)
            or rename("$filename.bak", $filename)
            or die "ERROR! Old file is in $filename.bak: $!";
    } else {
        rename("$filename.tmp", $filename)
            or die "Failed to create $filename: $!\n";
    }
    print "Wrote $filename, length ", (-s $filename), "\n";
    $dirty = 0;
}

sub current_path {
    return [ @current[1 .. $#current] ];
}

sub abspath {
    my ($path) = @_;
    return [ @{ current_path() }, @$path ];
}

sub cmd_search {
    my ($current, $pattern, $path, $args, $expr) = @_;
    $args ||= '';

    $path = parse_path($path);

    # Match a single container and chdir to it.
    my $do_chdir = $args =~ s/--cd//;

    # Search the names of directories instead of leaves.
    my $do_dirs = $args =~ s/--dirs?//;

    # Search both directories and leaves.
    my $do_all = $args =~ s/--all//;

    # Add up byte sizes of contents of all matching items. (?)
    my $do_size = $args =~ s/--size//;

    # Unimplemented. Delete matching items.
    my $do_delete = $args =~ s/--delete//;

    # Count... something. (?)
    my $do_count = $args =~ s/-c//;

    # Display paths of containers holding matches, rather than the matching
    # items themselves.
    my $do_list = $args =~ s/-l//;

    my $re;
    my $delim = substr($pattern, 0, 1);
    if (length($pattern) == 1 || $delim ne substr($pattern, -1)) {
        $re = $pattern;
    } else {
        $re = substr($pattern, 1, -1);
    }

    my %hist;
    my @matchfiles;
    my @deadmeat;

    my $type;
    if ($do_chdir) {
        $type = 'containers';
    } elsif ($do_all) {
        $type = 'all';
    } elsif ($do_dirs) {
        $type = 'keys';
    } elsif ($do_count) {
        $type = 'all';
    } else {
        $type = 'leaves';
    }

    map_path($current, $path, $type, sub {
        my ($stack, $lpath) = @_;

        my $segment = $lpath->[-1];
        return if $segment !~ /$re/;
        my $item = $1 // $segment; # If match expression contains parens, grab the matching portion.

        if (defined $expr) {
            # FIXME: leaf paths
            $item = evaluate($stack, $stack, abspath($lpath), $expr);
        }

        if ($do_count) {
            $hist{$item}++;
        } else {
            if ($do_size) {
                printf("% 8d bytes - ", calc_size($stack->[-1]));
            }

            if ($do_delete) {
                push @deadmeat, [ $stack, $segment, $lpath ];
            } elsif ($do_dirs || $do_all) {
                if (defined($stack->[-1])) {
                    print strpath($lpath);
                    if ($segment ne $item) {
                        print ": $item";
                    }
                    print "\n";
                } else {
                    print strpath(dirpath($lpath));
                    print ": $item\n";
                }
            } elsif ($do_list) {
                print strpath(dirpath($lpath)), "\n";
            } else {
                print "$item\n";
            }
        }
        push @matchfiles, strpath($lpath);
    }) or print "Path " . strpath($path) . " not found\n";

    if ($do_count) {
        for my $match (sort { $hist{$a} <=> $hist{$b} } keys %hist) {
            my $count = $hist{$match};
            printf("% 6s %s\n", $count, $match);
        }
    }

    if ($do_chdir) {
        return if @matchfiles == 0; # Already warned
        if (@matchfiles > 1) {
            print "Multiple matches; ambiguous destination\n";
            return;
        }
        chpath(dirpath($matchfiles[0]));
    }

    for my $deadmeat (sort { length($b->[2]) <=> length($a->[2]) || $b->[2] cmp $a->[2] } @deadmeat)
    {
        my ($stack, $key, $path) = @$deadmeat;

        # Want to get to the container of the key.
        #  - for a leaf path, we have [..., container, key, undef]
        #  - for a key path, we have [..., container, key]
        #  - for a container path, we have [..., container=key]??? We shouldn't have a container path.

        my $obj;
        if (defined($stack->[-1])) {
            $obj = $stack->[-2];
        } else {
            $obj = $stack->[-3];
            $key = $path->[-2];
        }

        if (UNIVERSAL::isa($obj, 'HASH')) {
            delete $obj->{$key};
        } elsif (UNIVERSAL::isa($obj), 'ARRAY') {
            splice(@$obj, $key, 1);
        }
        print "deleted " . strpath($path) . "\n" if $verbose;
    }
}

sub extract_aggregates {
    my ($expr) = @_;

    # regexp-based parsing, oh boy. Find all things like "$sum(...)" and
    # extract the ... part.
    my $re = qr{
      (                   # paren group 1 (full function)
          [=\$]\w+
          (                 # paren group 2 (parens)
            \(
              (             # paren group 3 (contents of parens)
              (?:
               (?> [^()]+ ) # Non-parens without backtracking
              |
               (?2)         # Recurse to start of paren group 2
              )*
              )
            \)
          )
        )
     }x;

    # No nesting allowed!

    my @aggregates;
    while ($expr =~ /$re/g) {
        my ($whole, $args) = ($1, $3);
        my $end = pos($expr);
        my $start = $end - length($whole);
        my $aend = $end - 1;
        my $astart = $aend - length($args);
        my ($function) = $whole =~ /[=\$](\w+)/;
        push @aggregates, {
            op => $function,
            whole => $whole,
            whole_range => [ $start, $end ],
            expr => '$(' . $args . ')', # All aggregates currently lookup their arg
            args_range => [ $astart, $aend ],
        };
    }

    return @aggregates;
}

sub op_count {
    return 0+@_;
}

sub op_min {
    my $min = shift // return;
    do { $min = $_ if $_ < $min } foreach @_;
    return $min;
}

sub op_max {
    my $max = shift // return;
    do { $max = $_ if $_ > $max } foreach @_;
    return $max;
}

sub op_sum {
    my $sum = 0;
    $sum += $_ foreach @_;
    return $sum;
}

# FIXME: this is computing a median of medians, not the overall median.
sub op_median {
    my @values = sort { $a <=> $b } @_;
    return $values[int(@values / 2)];
}

# FIXME: this is computing a mean of means, not the overall median.
sub op_mean {
    return 0 if @_ == 0;
    return op_sum(@_) / @_;
}

sub op_stats {
    my @stats = qw(count min max sum median mean);

    if (!@_ || $_[0] !~ /^\{/) {
        my %ret = map { $_ => $::{"op_$_"}->(@_) } @stats;
        return $pjson->encode(\%ret);
    }

    # @_ : [ str encoding { statname => value } ]

    my %data;
    foreach (map { $json->decode($_) } @_) {
        for my $stat (@stats) {
            push @{ $data{$stat} }, $_->{$stat};
        }
    }

    my %ret = map { $_ => $::{"op_$_"}->(@{ $data{$_} }) } @stats;
    $ret{fields} = \@stats;
    return $pjson->encode(\%ret);
}

sub op_group {
    # We are trying to determine the group. We will want to discard entries
    # with no group.
    return 'none' if @_ == 0;
    die "multiple groups found: @_" if @_ > 1;
    return shift;
}

sub compute_aggregate {
    my ($op, $values) = @_;

    return $::{"op_$op"}->(@$values);

    if ($op eq 'group') {
        # We are trying to determine the group. We will want to discard entries
        # with no group.
        return 'none' if @$values == 0;
        die "multiple groups found: @$values" if @$values > 1;
        return $values->[0];
    } elsif ($op eq 'sum') {
        return sum(@$values);
    } elsif ($op eq 'min') {
        return min(@$values);
    } elsif ($op eq 'max') {
        return max(@$values);
    } elsif ($op eq 'median') {
        return median(@$values);
    } else {
        die "Unknown aggregate function \$$op";
    }
}

sub evaluate_with_aggvalues {
    my ($expr, $aggregates, $aggvalues) = @_;
    for my $i (reverse 0..$#$aggregates) {
        my $agg = $aggregates->[$i];
        my $r = $agg->{whole_range};
        substr($expr, $r->[0], $r->[1] - $r->[0]) = compute_aggregate($agg->{op}, $aggvalues->[$i]);
    }

    return [
        map {
            s/ as (\S+)//;
            /^\{/ ? $json->decode($_) : eval
        } split(/;/, $expr)
    ];
}

sub unquote {
    local $_ = shift;
    s/'(.*?)'/$1/;
    return $_;
}

# Example: group markers/data/*/nursery '$sum(phase_times/Total)' by '$(reason)'
sub cmd_groupby {
    my ($current, $path, $expr, $groupexpr) = @_;
    $path = parse_path(unquote($path));
    $expr = unquote($expr);
    $groupexpr = unquote($groupexpr);
    (my $grouplabel = $groupexpr) =~ s/.* as (\S+)/$1/;
    $groupexpr =~ s/ as \S+//;

    my @aggregates = extract_aggregates($expr);
    my %group_values;
    # TODO: test example above
    map_path($current, $path, 'leaves', sub {
        my ($stack, $lpath) = @_;
        my $group = evaluate($stack, $stack, $lpath, $groupexpr, 'group');
        return if $group eq 'none';

        my @aggvalues;
        my $i = 0;
        for my $agg (@aggregates) {
            my $value = evaluate($stack, $stack, $lpath, $agg->{expr}, $agg->{op});
            push @{ $group_values{$group}[$i] }, $value;
        } continue {
            $i++;
        }
    });

    my @out;

    my $firstcols;
    for my $group (sort keys %group_values) {
        my $cols = evaluate_with_aggvalues($expr, \@aggregates, $group_values{$group});
        $firstcols //= $cols;
        # Ok, maybe I should rewrite this in another language. Or better yet,
        # inject the data into sqlite.
        push @out, [$group, map { ref ? @$_{@{ $_->{fields} }} : ($_) } @$cols];
    }

    my @subexprs = map { s/.* as (\S+)/$1/g; $_ } split(/;/, $expr);
    for my $i (reverse(1 .. $#$firstcols)) {
        my $datum = $firstcols->[$i];
        next if ! ref $datum;
        my $fields = $datum->{fields};
        splice(@subexprs, $i, 1, @$fields);
    }
    unshift @out, [$grouplabel, @subexprs];

    my @maxlens;
    for my $i (0..$#{ $out[0] }) {
        push @maxlens, op_max(map { length($_->[$i]) } @out);
    }
    my $format = "%$maxlens[0]s: " . join(" ", map { "%${_}s" } @maxlens[1..$#maxlens]) . "\n";
    foreach (@out) {
        printf($format, @$_);
    }
}

sub cmd_movegroup {
    my ($current, $pattern, $path, $dst) = @_;
    $path = parse_path($path);
    $dst = parse_path($dst);

    my $re;
    my $delim = substr($pattern, 0, 1);
    if ($delim ne substr($pattern, -1)) {
        $re = $pattern;
    } else {
        $re = substr($pattern, 1, -1);
    }

    my %tomove;
    my @tomove;
    map_path($current, $path, 'leaves', sub {
        my ($stack, $path) = @_;
        return if $stack->[-1] !~ /$re/;
        my $entry = dirpath($path);
        push @tomove, $entry if ++$tomove{strpath($entry)} == 1;
    }) or print "Path $path not found\n";

    print "tomove: " . strpath($_) . "\n" foreach @tomove;

    my $dest;
    eval {
        map_path($current, $dst, 'containers', sub {
            my ($stack, $path) = @_;
            if (!defined $dest) {
                if (! ref $stack->[-1]) {
                    print "$dst is a leaf, not a \"directory\"\n";
                    die "stop";
                } else {
                    $dest = $stack->[-1];
                }
            } else {
                print "$dst is not a unique directory\n";
                die "stop";
            }
        }) or print "Destination $dst not found\n";
    };

    # This isn't quite right -- it allows the destination to be multi-valued,
    # and puts a copy into each. Uh, call it a hidden feature.
    if ($dest) {
        my @deadmeat;
        for my $src (@tomove) {
            my $srcdata = enter($current, $src);
            add_entries($dest, $src, $srcdata);
            push @deadmeat, $src;
#            if (!map_path($current, $src, '???', sub {
#                my ($stack, $path) = @_;
#                add_entries($dest, $path, $stack->[-1]);
#                push @deadmeat, $path;
#            })) {
#                die "Source path $src not found\n";
#                return;
#            }
        }

        # Delete backwards so array contents don't get reshuffled
        for my $victim (reverse @deadmeat) {
            delete_keys($current, $victim);
        }

        print "Moved " . @tomove . " entries\n";
    }
}

sub parse_value {
    my ($value_str) = @_;
    return $1 if $value_str =~ /^"(.*)"$/;
    return $1 if $value_str =~ /^'(.*)'$/;

    return 0 + $value_str if $value_str =~ /^\d+$/;

    # TODO: parse JSON literals or something
    return {} if $value_str eq '{}';
    return [] if  $value_str eq '[]';

    $value_str =~ s/\\(.)/$1/g;
    return $value_str;
}

sub cmd_push_value {
    my ($struct, $value) = @_;

    if (!UNIVERSAL::isa($struct, 'ARRAY')) {
        print "Cannot push; not an array\n";
        return;
    }

    push @$struct, parse_value($value);
}

sub cmd_unshift_value {
    my ($struct, $value) = @_;

    if (!UNIVERSAL::isa($struct, 'ARRAY')) {
        print "Cannot push; not an array\n";
        return;
    }

    unshift @$struct, parse_value($value);
}

sub clone {
    my ($value) = @_;
    return $value if ! ref $value;
    return $json->decode($json->encode($value));
}

sub change_element {
    my ($struct, $key, $value) = @_;
    if (UNIVERSAL::isa($struct, 'HASH')) {
        $struct->{$key} = $value;
    } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
        $struct->[$key] = $value;
    } else {
        print "At a leaf node\n";
    }
}

sub cmd_set_value {
    my ($struct, $key, $value) = @_;
    set_value($struct, $key, $value);
}

sub set_value {
    my ($struct, $key, $value) = @_;
    $value = parse_value($value);

    my $keypath = parse_path($key);
    if (@$keypath > 1) {
        my $dir = shift(@$keypath);
        my $subkey = strpath($keypath);

        if (UNIVERSAL::isa($struct, 'HASH')) {
            if (exists $struct->{$dir}) {
                return set_value($struct->{$dir}, $subkey, $value);
            } else {
                return set_value($struct->{$dir} = {}, $subkey, $value);
            }
        } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
            if ($dir < @$struct) {
                return set_value($struct->[$dir], $subkey, $value);
            } else {
                return set_value($struct->[$dir] = {}, $subkey, $value);
            }
        } else {
            print "At a leaf node\n";
            return;
        }
    }

    if (UNIVERSAL::isa($struct, 'HASH')) {
        $struct->{$key} = $value;
        $dirty = 1;
    } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
        $struct->[$key] = $value;
        $dirty = 1;
    } else {
        print "At a leaf node\n";
    }
}

sub delete_keys {
    my ($current, $spec) = @_;

    my ($dir, $base) = splitpath($spec);
    map_path($current, $dir, 'all', sub {
        my ($stack, $path) = @_;
        my $struct = $stack->[-1];

        if ($base =~ /^(\d*)\s*\.\.\s*(\d*)$/) {
            my ($from, $to) = ($1, $2);
            $from = 0 if length($from) == 0;
            $to = $#$struct if length($to) == 0;
            if ($to > $#$struct) {
                print "End of range is too high (max $#$struct)\n";
                return;
            }
            splice(@$struct, $from, $to - $from + 1);
            $dirty = 1;
            return 1;
        } else {
            if (UNIVERSAL::isa($struct, 'ARRAY')) {
                if ($base > $#$struct) {
                    print "Index is too high (max $#$struct)\n";
                    return;
                }
                splice(@$struct, $base, 1);
                $dirty = 1;
                return 1;
            } elsif (exists $struct->{$base}) {
                delete $struct->{$base};
                $dirty = 1;
                return 1;
            } else {
                print "No such key '$base'\n";
            }
        }
    }) or print "Delete spec $spec not found\n";
}

sub cmd_delete_keys {
    my ($current, $spec) = @_;
    delete_keys($current, parse_path($spec));
}

sub filter_tree {
    my ($stack, $discard_func) = @_;

    my $obj = $stack->[-1];
    if (UNIVERSAL::isa($obj, 'HASH')) {
        my %newobj;
        my $discarded;
        while (my ($key, $value) = each %$obj) {
            if ($discard_func->($key)) {
                $discarded = 1;
            } else {
                $newobj{$key} = $value;
            }
        }

        if ($discarded) {
            %$obj = %newobj;
        }
    } elsif (UNIVERSAL::isa($obj, 'ARRAY')) {
        my @newobj;
        for my $i (reverse(0 .. $#$obj)) {
            my $elt = $obj->[$i];
            if (!$discard_func->($i)) {
                push @newobj, filter_tree(pushstack($stack, $elt), $discard_func);
            }
        }
        if (@newobj != @$obj) {
            @$obj = @newobj;
        }
    }

    return $obj;
}

# You are in the "directory" $stack->[-1] and want to look up $component,
# returning a new directory and a path telling you how you got there. Or if the
# $component matches multiple entries, return multiple <directory,path> pairs.
#
# EXCEPT: if $type indicates you want leaves, then this will *also* go a step
# further and give you a stack with a dummy 'undef' entry and a "path"
# terminated with the actual leaf data.
#
sub path_stacks {
    my ($stack, $component, $sofar, $suppress_errors, $type) = @_;

    die if ref $component;
    my $obj = $stack->[-1];

    my @stacks;
    if ($component eq '*') {
        for my $key (all_keys($obj)) {
            my $s = append($stack, $key, $type, 'no-errors') // next;
            $DB::single = 1 if ! $s;
            push @stacks, [ $s, [ @$sofar, $key ] ];
        }
    } elsif ($component eq '**') {
        for my $path (all_paths($obj, $type)) {
            my $s = appendPath($stack, $path, $type, 'no-errors') // next;
            $DB::single = 1 if ! $s;
            push @stacks, [ $s, joinpath($sofar, $path) ];
        }
    } elsif ($component =~ /^\{(.*)\}$/) {
        my $guts = $1;
        for my $alt (split(/;/, $guts)) {
            push @stacks, path_stacks($stack, $alt, $sofar, $suppress_errors, $type);
        }
    } else {
        $sofar = joinpath($sofar, $component);
        if ($component eq '.' || $component eq '') {
            $DB::single = 1 if ! $stack;
            push @stacks, [ $stack, $sofar ];
        } elsif ($component eq '..') {
            push @stacks, [ popstack($stack), $sofar ];
        } else {
            my $s = append($stack, $component, $type, $suppress_errors)
                or return;
            $DB::single = 1 if ! $s;
            push @stacks, [ $s, $sofar ];
        }
    }

    return @stacks;
}

# Callback is invoked with (object, path). 'object' is the structure at the
# given path. It may be a leaf or a struct.
sub map_path {
    my ($stack, $path, $type, $callback, $suppress_errors, $sofar) = @_;

    $path //= ['.'];
    $sofar //= [];

    $callback //= sub { my ($stack, $lpath) = @_; return $lpath; };

    # Absolute path
    if ($path->[0] eq '/') {
        $path = shiftpath($path);
        $path = ['.'] if ! @$path;
        $stack = [ $stack->[0] ];
        $sofar = ['/'];
    }

    my @results;

    my $obj = $stack->[-1];
    if (@$path == 1) {
        # Single component "$path"
        foreach (path_stacks($stack, $path->[0], $sofar, $suppress_errors, $type)) {
            my ($stack, $sofar) = @$_;
            push @results, $callback->($stack, $sofar) // 1;
        }
    } else {
        # "$first/$rest"
        my $first = $path->[0];
        my $rest = shiftpath($path);
        foreach (path_stacks($stack, $first, $sofar, $suppress_errors, 'containers')) {
            my ($stack, $sofar) = @$_;
            $suppress_errors ||= $first =~ /^[\*\{]/;
            push @results, map_path($stack, $rest, $type, $callback, $suppress_errors, $sofar);
        }
    }

    return @results;
}

sub popstack {
    my ($stack) = @_;
    return [ @$stack[0..$#$stack-1] ];
}

sub evaluate {
    my ($current, $stack, $path, $expr, $multi) = @_;

    # TEMP! FIXME! TODO!
    $path = join("/", @$path) if ref $path;

    my $output = $expr;
    $output =~ s/\{basename\}/$stack->[-1]/g;
    $output =~ s/\{path\}/$path/g;
    my $dir = dirname($path);
    $output =~ s/\{dir\}/$dir/g;

    my $lookup = sub {
        my ($current, $lookup_path) = @_;

        my @found = map_path($current, $lookup_path, 'all', sub {
            my ($lstack, $lpath) = @_;
            return $lstack->[-1];
        });

        return compute_aggregate($multi, \@found) if $multi;

        if (@found == 0) {
            $DB::single = 1;
            die "path $lookup_path not found\n";
        } elsif (@found > 1) {
            die "path $lookup_path resolved to multiple locations\n";
        }
        return $found[0];
    };

    my $sum = sub {
        my ($current, $lookup_path) = @_;

        my $sum = 0;
        map_path($current, $lookup_path, 'leaves', sub {
            my ($lstack, $lpath) = @_;
            $sum +=  $lstack->[-1];
        });

        return $sum;
    };

    # Lookup $(path)
    $output =~ s/[=\$]\((.*?)\)/$lookup->($current, $1)/eg;

    # Evaluate $eval(...) as a Perl expression.
    $output =~ s/[=\$]eval\((.*)\)/$1/ee;

    # $sum(path) gives the sum of everything matching path.
    $output =~ s/[=\$]sum\((.*?)\)/$sum->($current, $1)/eg;

    return $output;
}

sub cmd_transform {
    my ($current, $path, $expr, $dest_arg) = @_;
    $path = parse_path($path);

    my $dest;
    if ($dest_arg && $dest_arg =~ /-d (.*?)\s*$/) {
        $dest = parse_path($1);
    }
    eval {
        map_path($current, $path, 'leaves', sub {
            my ($stack, $path) = @_;
            my $output = evaluate($current, $stack, $path, $expr);

            if (!$dest) {
                change_element($stack->[-2], $stack->[-1], $output);
            } else {
                map_path($stack, joinpath("..", $dest), 'keys', sub {
                    my ($lstack, $lpath) = @_;
                    set_value($lstack->[-1], basename($dest), $output);
                });
            }
        });
    };

    print $@ if $@;
}

sub cmd_ls {
    my ($current, $lspath) = @_;
    $lspath = parse_path($lspath, '.');

    map_path($current, $lspath, 'keys', sub {
        my ($stack, $path) = @_;
        $DB::single = 1 if !ref $stack;
        if (num_elements($stack->[-1]) > 0) {
            my $HERE = @$lspath == 0 && @$path == 1 && $path->[0] eq '.';
            print strpath($path) . "/\n" if not $HERE;
            my $prefix = $HERE ? "" : "  ";
            my $stacktop = $stack->[-1];
            if (UNIVERSAL::isa($stacktop, 'ARRAY') && @$stacktop >= 8) {
                print "${prefix}indexes 0 .. $#$stacktop\n";
            } else {
                for my $key (all_keys($stacktop)) {
                    print $prefix, entry_str($stacktop, $key), "\n";
                }
            }
        } else {
            print strpath($path), "\n";
        }
    }) or print "Path " . strpath($lspath) . " not found\n";
}

sub add_entries {
    my ($node, $path, $value) = @_;
    my $stem = $path->[-1];
    die "Cannot append to leaf" if ! ref $node;
    if (UNIVERSAL::isa($node, 'ARRAY')) {
        if ($stem =~ /^\d+$/) {
            push @$node, $value;
            $dirty = 1;
        } else {
            print "Cannot append named value to array\n";
        }
    } else {
        if ($stem =~ /^\d+$/) {
            # FIXME: This should really check that the parent is an array
            print "Cannot add array element to a hash\n";
        } else {
            $node->{$stem} = $value;
            $dirty = 1;
        }
    }
}

sub cmd_mv {
    my ($current, $src, $dst) = @_;
    $src = parse_path($src);
    $dst = parse_path($dst);

    my $dest;
    eval {
        map_path($current, $dst, 'all', sub {
            my ($stack, $path) = @_;
            if (!defined $dest) {
                if (! ref $stack->[-1]) {
                    print "$dst is a leaf, not a \"directory\"\n";
                    die "stop";
                } else {
                    $dest = $stack->[-1];
                }
            } else {
                print "$dst is not a unique directory\n";
                die "stop";
            }
        }) or print "Destination $dst not found\n";
    };

    if ($dest) {
        my @deadmeat;
        map_path($current, $src, 'keys', sub {
            my ($stack, $path) = @_;
            add_entries($dest, $path, $stack->[-1]);
            push @deadmeat, $path;
        }) or do {
            print "Source path $src not found\n";
            return;
        };

        # Delete backwards so array contents don't get reshuffled
        for my $victim (reverse @deadmeat) {
            delete_keys($current, $victim);
        }
    }
}

sub cmd_sum {
    my ($current, $path) = @_;
    $path = parse_path($path);

    my $sum = 0;
    map_path($current, $path, 'leaves', sub {
        my ($stack, $lpath) = @_;
        $sum += $stack->[-1];
    });
    print "$sum\n";
}

sub calc_size {
    my ($obj) = @_;
    return length($json->allow_nonref->encode($obj));
}

sub map_size {
    my ($current, $path, $func) = @_;

    my $found;
    map_path($current, $path, 'all', sub {
        my ($stack, $lpath) = @_;
        $func->($stack, $lpath, calc_size($stack->[-1]));
        $found = 1;
    }) or return undef;

    return $found;
}

sub cmd_show_size {
    my ($current, $path_str) = @_;
    my $show_keys = defined($path_str);
    $path_str //= '.';
    my $path = parse_path($path_str);

    map_size($current, $path, sub {
        my ($stack, $lpath, $len) = @_;
        if ($show_keys) {
            print strpath($lpath) . " = $len bytes\n";
        } else {
            print "$len bytes\n";
        }
    }) or print "Path $path_str not found\n";
}

sub cmd_cat {
    my ($current, $nokeys, $path_str, $outfile) = @_;
    my $path = parse_path($path_str, '.');

    my $out = $outfile ? IO::File->new("> $outfile") : \*STDOUT
        or die "create $outfile: $!";

    map_path($current, $path, 'all', sub {
        my ($stack, $lpath) = @_;
        if (num_elements($stack->[-1]) > 0) {
            print $out strpath($lpath, '/'), " with ", num_elements($stack->[-1]), " keys:\n";
            print $out $pjson->encode($stack->[-1]);
        } elsif (! ref $stack->[-1]) {
            print $out strpath($lpath) . " = " unless $nokeys;
            print $out "$stack->[-1]\n";
        } elsif (UNIVERSAL::isa($stack->[-1], 'ARRAY')) {
            print $out "empty array\n";
        } else {
            print $out "empty hash\n";
        }
    }) or print "Path $path_str not found\n";
}

sub printExcess {
    my ($total, $printed) = @_;
    print "...plus " . ($total - $printed) . " more, $total total... (limit N to display more than $MAX)\n";
}

# Given a struct of some sort and a key, return the value at that key.
sub enter {
    my ($struct, $key, $suppress_error, $found) = @_;
    if (UNIVERSAL::isa($struct, 'HASH')) {
        $$found = exists $struct->{$key} if $found;
        return $struct->{$key};
    } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
        if ($key !~ /^-?\d+$/) {
            print "Non-numeric key '$key' for array\n" unless $suppress_error;
            return;
        }

        return if @$struct == 0;

        # This is horrible. Handle negative indexes.
        $_[1] = ($key + @$struct) % @$struct;

        $$found = ($key >= -$#$struct) && ($key < @$struct) if $found;

        return $struct->[$key];
    } else {
        return if $suppress_error;
        print "No such key '$key'\n" unless $suppress_error;
        return;
    }
}

sub includes_leaves {
    my ($type) = @_;
    return $type eq 'leaves' || $type eq 'all';
}

sub append {
    my ($stack, $key, $type, $suppress_error) = @_;
    my $found;
    my $obj = enter($stack->[-1], $key, $suppress_error, \$found);
    return [ @$stack, $obj ] if $found;

    if ($stack->[-1] eq $key && includes_leaves($type)) {
        return [ @$stack, undef ];
    }
}

sub appendPath {
    my ($stack, $rpath, $type, $suppress_error) = @_;
    for my $component (@$rpath) {
        $stack = append($stack, $component, $type, 1) // return;
    }
    return $stack;
}

sub enterPath {
    my ($stack, $path, $suppress_errors) = @_;
    my @stack = @$stack;
    for my $segment (@$path) {
        push @stack, enter($stack[-1], $segment, $suppress_errors)
            or return;
    }
    return \@stack;
}

sub num_elements {
    my ($value) = @_;

    if (UNIVERSAL::isa($value, 'HASH')) {
        return scalar(keys %$value);
    } elsif (UNIVERSAL::isa($value, 'ARRAY')) {
        return scalar(@$value);
    } else {
        return 0;
    }
}

sub chkey {
    my ($key) = @_;

    if ($key eq '.') {
        return 1;
    } elsif ($key eq '..') {
        if (@current > 1) {
            pop(@current);
            pop(@$current);
            return 1;
        } else {
            print "Already at top\n";
        }
    } else {
        my $new = enter($current->[-1], $key)
          or return;
        if (!ref($new)) {
            print "'$key' is a leaf\n";
        } else {
            push @current, $key;
            push @$current, $new;
            return 1;
        }
    }

    return;
}

sub all_keys {
    my ($value) = @_;
    if (UNIVERSAL::isa($value, 'HASH')) {
        return sort keys %$value;
    } elsif (UNIVERSAL::isa($value, 'ARRAY')) {
        return 0 .. $#$value;
    } else {
        return;
    }
}

# FIXME: Does not distinguish between a leaf value and an empty container
sub all_leaf_paths {
    my ($obj) = @_;
    return $obj if ! ref($obj);

    my @paths;
    for my $key (all_keys($obj)) {
        my $entry = enter($obj, $key, 'no-errors');
        if (ref($entry)) {
            for my $path (all_leaf_paths($entry)) {
                push @paths, joinpath($key, $path);
            }
        } else {
            push @paths, $key;
        }
    }

    return @paths;
}

# Return all paths starting at the given root, as arrays of path segments.
# $root is a ref to a container or a leaf.
#
# type can be 'containers', 'keys', or 'leaves'.
#   containers - full paths to all containers (dicts and arrays)
#   keys - full paths to all keys within containers
#   leaves - full paths to only leaves
#   all - full paths to everything
#
# FIXME: do I really want to go all the way to the leaf values? They're not really paths.
sub all_paths {
    my ($root, $type) = @_;
    $type //= 'leaves';

    if (! ref($root)) {
        return if $type eq 'containers' || $type eq 'keys';
        return ([$root]);
    }

    my @paths;
    for my $key (all_keys($root)) {
        my $value = enter($root, $key, 'no-errors');
        if (! ref $value) {
            push @paths, [$key] if $type eq 'keys' || $type eq 'all';
            if (defined $value) {
                push @paths, [$key, $value] if $type eq 'leaves' || $type eq 'all';
            }
        } else {
            push @paths, [$key] if $type ne 'leaves';
            if (defined $value) {
                push @paths, map { joinpath($key, $_) } all_paths($value, $type);
            }
        }
    }

    return @paths;
}

sub chpath {
    my ($path) = @_;

    my $old_current = $current;
    my @old_current = @current;

    if ($path->[0] eq '/') {
        $current = [ $struct ];
        splice(@current, 1);
    }

    for my $key (@$path) {
        if (!chkey($key)) {
            $current = $old_current;
            @current = @old_current;
            print "Path component '$key' not found\n";
            return 0;
        }
    }

    return 1;
}

# This isn't exactly right, but it's kinda close
sub shortjoin {
    my $maxlen = shift;

    my (@head, @tail);
    my $left = $maxlen - 1;
    while (@_ > 0 && $left > 0) {
        if ($left > length($_[-1]) + 1) {
            unshift @tail, pop(@_);
            $left -= length($tail[-1]) + 1;
            last if @_ == 0;
            if ($left > length($_[0]) + 1) {
                push @head, shift(@_);
                $left -= length($head[-1]) + 1;
            }
        } else {
            last;
        }
    }

    if (@_ > 0) {
        push @head, "...";
    }

    return join("/", "", @head, @tail);
}

sub quit {
    if ($dirty) {
        my $input = $term->readline("Unsaved changes exist. Are you sure you want to exit (y/n)? ");
        unless ($input =~ /^y/i) {
            print "Continuing\n";
            return;
        }
    }

    exit(0);
}
