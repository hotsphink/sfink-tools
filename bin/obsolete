#!/usr/bin/python3

# Two functions:
# 1. Find the most recent public changesets for a given set of local draft changesets.
# 2. Given two sets of changesets (one public, one draft), hg prune --pair the appropriate ones.

import argparse
import re
import shlex
import subprocess
import sys

from collections import namedtuple

Node = namedtuple("Node", ["rev", "phase", "bug", "num", "reviewers", "desc"])

p = argparse.ArgumentParser(
    usage='obsolete [options]', description='''\
Take a set of draft revisions and find their landed equivalents, then output a command that prunes the given revisions, setting the landed equivalents as their successors.

Example: obsolete -r .^^^::. --user=sfink --branch=autoland'''
)

g = p.add_argument_group('specifying revisions')
g.add_argument("--deadmeat", "--draft", "--local", "--revisions", "-r",
               help="The revset for the revisions to prune")
g.add_argument("--landed", "--public", "--successors", "-s",
               help="The revset for the successor revisions that have landed")
g.add_argument("--user",
               help="A userid to scan to find landed revs")
g.add_argument("--branch", default='central',
               help="Label of a branch to scan for landed revisions")
g.add_argument("--landed-from",
               help="Parse this file to extract the landed revisions")
g.add_argument("--limit", "-l", type=int,
               help="Do not look more than LIMIT revisions back")

p.add_argument("--verbose", "-v", action="store_true",
               help="Verbose output")
p.add_argument("--debug", "-D", action="store_true",
               help="Debugging output")

g = p.add_argument_group('output syntax')
g.add_argument("--numeric", "-n", action="store_true",
               help="Use local numeric changeset numbers instead of hashes")

args = p.parse_args()


def gather_revisions(revset, query=None):
    revs = {}
    lookup = {}
    if query:
        lookup = {n.desc: n for n in query.values()}

    cmd = [
        "hg", "log",
        "-r", revset,
        "-T", "{phase} {rev}:{node|short} {desc|firstline}\\n"
    ]
    if args.limit:
        cmd.extend(["-l", str(args.limit)])
    if args.debug:
        print(f"Running {shlex.join(cmd)}")

    n = 0
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, text=True)
    for line in iter(process.stdout.readline, ''):
        n += 1
        if n % 1000 == 0:
            if query:
                print(f"..found {len(revs)}/{len(query)} after processing {n} revisions..")
            else:
                print(f"..found {len(revs)} after processing {n} revisions..")

        m = re.match(r"(\w+) (\w+):(\w+) (.*)", line)
        if not m:
            raise Exception("invalid format: '{}'".format(line))
        phase, num, rev, desc = m.groups()

        if m := re.match(r"[bB]ug (\d+)\W*(.*)", desc):
            bug = m.group(1)
            desc = m.group(2)
        else:
            bug = None

        if m := re.match(r"(.*?)\s*r[?=]([\w., ]+)$", desc):
            desc = m.group(1)
            reviewers = m.group(2)
        else:
            reviewers = None

        node = Node(rev, phase, bug, num, reviewers, desc)

        if lookup:
            if desc not in lookup:
                continue

            deadmeat = lookup.pop(desc)
            if deadmeat.bug != node.bug:
                print(f"Warning: landed {node.rev} as bug {node.bug}, draft rev is bug {deadmeat.bug}")
                print("  - " + desc)
            if args.verbose:
                print(f'found {node.rev} ("{desc}")')

        revs[rev] = node

        if query and not lookup:
            break  # Stop early, found everything

    if lookup:
        print("Failed to find:")
        for node in lookup.values():
            print(f'  {node.rev} ("{node.desc}")')

    return revs

if args.verbose:
    print("Gathering revisions to prune...")
deadmeat = gather_revisions(args.deadmeat)
print(f"Gathered {len(deadmeat)} revisions to obsolete")

if args.landed_from:
    pieces = []
    with open(args.landed_from, "rt") as fh:
        for line in fh:
            # a revision url, as if it were cut & paste from an automated bug comment
            if m := re.search(r'/rev/(\w+)', line):
                pieces.append(m.group(1))
                # a short hash
            else:
                if m := re.match(r'^([a-f0-9]{12})$', line):
                    pieces.append(m.group(1))
                else:
                    if args.debug:
                        print(f"Ignoring: {line}")
                        landed = gather_revisions("+".join(pieces))
elif args.landed:
    landed = gather_revisions(args.landed)
else:
    print(f"Scanning {args.branch} for matching ancestor revisions...")
    if args.user:
        landed = gather_revisions(f"reverse(ancestors({args.branch})) and public() and user('{args.user}')",
                               query=deadmeat)
    else:
        landed = gather_revisions(f"reverse(ancestors({args.branch})) and public()",
                               query=deadmeat)
    print(f"Found {len(landed)}/{len(deadmeat)} successor revisions")

if args.debug:
    print(f"old = {deadmeat.keys()}\n")
    print(f"new = {landed.keys()}\n")

if len(deadmeat) != len(landed):
    print(f"Cannot replace {len(deadmeat)} revs with {len(landed)} revs")
    sys.exit(1)

if any(n.phase == 'public' for n in deadmeat.values()):
    print("This command is only for obsoleting draft revs")
    sys.exit(1)

if any(n.phase != 'public' for n in landed.values()):
    print("Cannot obsolete public revs")
    sys.exit(1)

oldv = sorted(deadmeat.values(), key=lambda n: n.num)
newv = sorted(landed.values(), key=lambda n: n.num)

failed = False
for i in range(len(oldv)):
    old = oldv[i]
    new = newv[i]
    print(f"{old.rev} -> {new.rev} {new.desc}")
    if old.desc != new.desc:
        print(f"For now, cowardly refusing to obsolete\n  {old['desc']}\nwith\n  {new['desc']}")
        failed = True

if failed:
    sys.exit(1)


def vec2revset(vec):
    seq = []
    for node in vec:
        if not seq:
            seq.append([node, node])
        elif int(node.num) == int(seq[-1][1].num) + 1:
            seq[-1][1] = node
        else:
            seq.append([node, node])

    if args.numeric:
        return '+'.join([first.num if first == last
                         else f"{first.num}:{last.num}"
                         for first, last in seq])
    else:
        return '+'.join([first.rev if first == last
                         else f"{first.rev}:{last.rev}"
                         for first, last in seq])


oldrevset = vec2revset(oldv)
newrevset = vec2revset(newv)

print()
print(f"hg prune --pair -r {oldrevset} --succ {newrevset}")
