#!/usr/bin/perl

use JSON;
use File::Basename qw(dirname basename);
use Term::ReadLine;
use Getopt::Long;
use strict;
use warnings;

my $json = JSON->new->utf8->relaxed;
my $pjson = JSON->new->utf8->relaxed->canonical->pretty;

# transform markers/name/* /threads/2/stringArray/{value}

sub help {
    my ($opts) = @_;

    if ($opts->{error}) {
        print STDERR $opts->{error}, "\n";
    }

    print <<"END";
Usage: $0 <filename.json> [initial-path] [-e COMMAND]

    ls [PATH]              - show contents of structure
    cd PATH                - change current view to PATH
    cat [--nokeys] [PATH]  - display the value at the given PATH
    delete SPEC            - delete the given key or range of keys (see below
                             for a description of SPEC)
    set KEY VALUE          - modify an existing value (VALUE may optionally
                             be quoted)
    transform PATH LOOkUP  - for every value VSRC found at PATH, convert LOOKUP
                             to a new path by substituting "{value}" with VSRC,
                             and replace VSRC with the value found at that path
    mv PATH PATH           - move a subtree
    mmv PATTERN PATH DEST  - move all immediate children in PATH matching
                             PATTERN to DEST
    grep [-l] PATTERN PATH - search for PATTERN in given PATH
    write [--pretty|--noindent] [FILENAME]
                           - write out the whole structure as JSON. Use '-' as
                             FILENAME to write to stdout.
    pretty                 - prettyprint current structure to stdout
    size PATH              - display how many bytes the JSON of the substructure
                             at PATH would take up
    load [FILENAME]        - load in the given JSON file (reload current file
                             if no filename given)
    export FILENAME        - write the current subtree into the given file
    import FILENAME [DEST] - imports the given JSON file into the current location
                             (under the key DEST, if given)
    quit                   - exit this program
    help                   - show this message

Paths:

    PATHs are slash-separated sequences of key names, '.', '..', '*', or '**'.
    '**' means a recursive search.

Delete Specifications:

    A delete SPEC can be a plain key name, or a range of the format 'M..N',
    where one of M and N may be optional. M defaults to zero. N defaults to the
    highest index available. Ranges are inclusive.
END

    exit 1 if $opts->{error};
    exit 0 if $opts->{exit};
}

my @inputbuffer;

# Fix bizarre readline bug where it spews some crap into stdout on shutdown.
# My attempts to fix it via $term->variable_bind("enable-meta-key", "off")
# and similar did not work.
if (defined $ENV{TERM}) {
    $ENV{TERM} =~ s/xterm-256color/vt100/;
}

my $term = Term::ReadLine->new("JSON explorer");
our $oldout = select($term->OUT || \*STDOUT) if (-t STDOUT);
END { select($oldout) if $oldout; }
my $attribs = $term->Attribs;

my $MAX = 10;
my $struct;
my $dirty = 0;
my $current;
my @current;
my $batch = 0;

GetOptions("h|help!" => sub { help({ exit => 1 }) },
           "e|command=s" => \@inputbuffer)
    or help({ error => 'invalid arguments' });

if ((! -t STDIN) && (@ARGV == 0)) {
    @ARGV = ('-');
}
help({error => 'not enough arguments'}) if @ARGV == 0;

$batch = 1 if @inputbuffer;

my $current_file = shift(@ARGV);

load();

if (@ARGV) {
    my $init_path = shift(@ARGV);
    if (!chpath($init_path)) {
        die "No path '$init_path' found, exiting.\n";
    }
}

if (!$batch && ! -t STDIN) {
    prettyprint($current->[-1]);
    exit 0;
}

my @completions;
my $c_i;
sub completion {
    my ($text, $generating) = @_;

    $attribs->{filename_completion_desired} = 1;
    $attribs->{filename_quoting_desired} = 1;

    if (!$generating) {
        if ($text =~ m!(.*)/[^/]*$!) {
            my ($complete, $prefix) = ($1, $2);
            my $stack = enterPath($current, $1, 1);
            if ($stack) {
                @completions = map { "$complete/$_" } get_completions($stack->[-1]);
            } else {
                @completions = ();
            }
        } else {
            @completions = get_completions($current->[-1]);
        }
    }

    $c_i = $generating ? $c_i + 1 : 0;
    for (; $c_i < @completions; $c_i++) {
        my $option = $completions[$c_i];
        if (index($option, $text) == 0) {
            $attribs->{completion_append_character} =
                ($option =~ m!/$! ? "\0" : " ");
            return $option;
        }
    }
    return undef;
}
$attribs->{completion_entry_function} = \&completion;
$attribs->{completer_word_word_break_characters} .= "/";
$attribs->{completer_quote_characters} = "'";
$attribs->{filename_quote_characters} = "'";

sub entry_str {
    my ($obj, $key) = @_;
    my $str = $key;
#    if ($key =~ m!/!) {
#        $str = "'$str'";
#    }

    my $entry = enter($obj, $key, 1);
    $str .= "/" if defined($entry) && ref($entry);
    $str .= "?" if !defined($entry);
    return $str;
}

sub get_completions {
    my ($obj) = @_;
    #return map { entry_str($obj, $_) } all_keys($obj);
    return all_keys($obj);
}

sub nextcommand {
    my ($prompt) = @_;
    return shift(@inputbuffer) if @inputbuffer;
    return if $batch;
    return $term->readline("$prompt> ");
}

LS: while(1) {
    ls($current) unless $batch;

    while (1) {
        my $prompt = shortjoin(50, @current[1..$#current]);
        my $input = nextcommand($prompt);
        if (! defined $input) {
            quit();
            next;
        }
        chomp($input);
        $term->addhistory($input) if $input =~ /\S/;

        $input =~ s/\s+$//;
        if ($input eq 'help') {
            help();
        } elsif ($input =~ /^cd (.*?)$/) {
            next LS if chpath($1);
        } elsif ($input =~ /^cat$/) {
            cat($current);
        } elsif ($input =~ /^cat (--nokeys )?(.*?)$/) {
            cat($current, $1, $2);
        } elsif ($input =~ /^ls$/) {
            next LS;
        } elsif ($input =~ /^ls (.*?)$/) {
            ls($current, $1);
        } elsif ($input =~ /^limit (\d+)$/) {
            $MAX = $1;
        } elsif ($input =~ /^delete (.*?)$/) {
            delete_keys($current, $1);
        } elsif ($input =~ /^set (\S+)[\s=]+(.*)$/) {
            set_value($current->[-1], $1, $2);
        } elsif ($input =~ /^transform (\S+)\s+(.*)$/) {
            transform($current, $1, $2);
        } elsif ($input =~ /^push (.*)$/) {
            push_value($current->[-1], $1);
        } elsif ($input =~ /^unshift (.*)$/) {
            unshift_value($current->[-1], $1);
        } elsif ($input =~ /^mv (\S+) (\S+)$/) {
            mv($current, $1, $2);
        } elsif ($input =~ /^grep (?:(-l|--cd)\s+)?(.*) (\S+)$/) {
            search($2, $3, $1);
        } elsif ($input =~ /^mmv (.*) (\S+) (\S+)$/) {
            movegroup($1, $2, $3);
        } elsif ($input =~ /^write (?:(--\w+)\s*)?(.*?)$/) {
            write_file($2, $1);
        } elsif ($input =~ /^write(?: (--\w+))?$/) {
            write_file($ARGV[0], $2);
        } elsif ($input =~ /^pretty$/) {
            prettyprint($current->[-1]);
        } elsif ($input =~ /^load (.*?)$/) {
            load($1);
        } elsif ($input =~ /^(load|reload)$/) {
            load();
        } elsif ($input =~ /^import (\S+)(?: (.*))?$/) {
            import($current->[-1], $1, $2);
        } elsif ($input =~ /^export (.*?)$/) {
            export($current->[-1], $1);
        } elsif ($input =~ /^size (.*?)$/) {
            show_size($current, $1);
        } elsif ($input =~ /^size$/) {
            show_size($current);
        } elsif ($input =~ /^quit$/) {
            quit();
        } else {
            print "Unrecognized command\n";
        }
    }
}

sub load {
    my ($file) = @_;
    $file //= $current_file;
    use IO::Zlib;
    # Sadly, IO::Zlib ignores $/ so there's no good way to slurp a file.
    my $data = do {
        local $/; # Maybe someday...
        my $fh = IO::Zlib->new($file, 'r') or die "open $file: $!";
        join('', $fh->getlines)
    };
    eval {
        $struct = $json->decode($data);
    };
    if ($@) {
        print "Failed to parse JSON text: $@";
        open(my $F, ">", "/tmp/shit.json");
        print $F $data;
        close($F);
        die $@;
    }
    $current = [ $struct ];
    @current = ( "[top]" );
    $current_file = $file;
    $dirty = 0;
}

sub export {
    my ($struct, $file) = @_;
    
    open(my $fh, ">", $file) or die "create $file: $!";
    my $json = $pjson->utf8->canonical;
    print $fh $json->encode($struct)
        or die "writing to $file: $!";
}

sub import {
    my ($struct, $file, $dest) = @_;
    my $data = do { local $/; open(my $fh, "<", $file) or die "open $file: $!"; <$fh> };
    my $value = $json->decode($data);
    if (defined $dest) {
        if (UNIVERSAL::isa($struct, 'HASH')) {
            $struct->{$dest} = $value;
        } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
            $struct->[$dest] = $value;
        } else {
            print "At a leaf node\n";
        }
    } else {
        if (UNIVERSAL::isa($struct, 'HASH')) {
            if (UNIVERSAL::isa($value, 'HASH')) {
                $struct->{$_} = $value->{$_} foreach keys %$value;
            } else {
                print "Mismatched types\n";
            }
        } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
            if (UNIVERSAL::isa($value, 'HASH')) {
                push @$struct, $value;
            } else {
                push @$struct, @$value;
            }
        }
    }
        
    $dirty = 1;
}

sub prettyprint {
    my ($struct) = @_;
    print $pjson->encode($struct);
}

sub write_file {
    my ($filename, $arg) = @_;
    $filename ||= $current_file;
    $arg ||= '';

    my $fh;
    if ($filename eq '-') {
        $fh = \*STDOUT;
    } else {
        open($fh, ">", "$filename.tmp")
            or die "create $filename.tmp: $!";
    }

    my $json = $json->utf8; #->canonical;
    $json = $json->pretty if $arg;
    my $out = $json->encode($struct);
    $out =~ s/^\s+//mg if $arg eq '--noindent';
    print $fh $out
        or die "writing to $filename.tmp: $!";

    return if $filename eq '-';

    close($fh)
        or die "closing $filename.tmp: $!";
    if (rename($filename, "$filename.bak")) {
        rename("$filename.tmp", $filename)
            or rename("$filename.bak", $filename)
            or die "ERROR! Old file is in $filename.bak: $!";
    } else {
        rename("$filename.tmp", $filename)
            or die "Failed to create $filename: $!\n";
    }
    print "Wrote $filename, length ", (-s $filename), "\n";
    $dirty = 0;
}

sub search {
    my ($pattern, $path, $args) = @_;
    $args ||= '';

    my $re;
    my $delim = substr($pattern, 0, 1);
    if (length($delim) < 2 || $delim ne substr($pattern, -1)) {
        $re = $pattern;
    } else {
        $re = substr($pattern, 1, -1);
    }

    my @matchfiles;
    map_path($current, $path, sub {
        my ($stack, $path) = @_;
        return if ref($stack->[-1]);
        return if $stack->[-1] !~ /$re/;
        if ($args ne '--cd') {
            print $path;
            if (!$args) {
                print ": $stack->[-1]";
            }
            print "\n";
        }
        push @matchfiles, $path;
    }) or print "Path $path not found\n";

    if ($args eq '--cd') {
        return if @matchfiles == 0; # Already warned
        if (@matchfiles > 1) {
            print "Multiple matches; ambiguous destination\n";
            return;
        }
        chpath(dirname($matchfiles[0]));
    }
}

sub movegroup {
    my ($pattern, $path, $dst) = @_;
    
    my $re;
    my $delim = substr($pattern, 0, 1);
    if ($delim ne substr($pattern, -1)) {
        $re = $pattern;
    } else {
        $re = substr($pattern, 1, -1);
    }

    my %tomove;
    my @tomove;
    map_path($current, $path, sub {
        my ($stack, $path) = @_;
        return if ref($stack->[-1]);
        return if $stack->[-1] !~ /$re/;
        my ($entry) = $path =~ m!([^/]+?)(?:/|$)!;
        push @tomove, $entry if ++$tomove{$entry} == 1;
    }) or print "Path $path not found\n";

    print "tomove: $_\n" foreach @tomove;

    my $dest;
    eval {
        map_path($current, $dst, sub {
            my ($stack, $path) = @_;
            if (!defined $dest) {
                if (! ref $stack->[-1]) {
                    print "$dst is a leaf, not a \"directory\"\n";
                    die "stop";
                } else {
                    $dest = $stack->[-1];
                }
            } else {
                print "$dst is not a unique directory\n";
                die "stop";
            }
        }) or print "Destination $dst not found\n";
    };

    # This isn't quite right -- it allows the destination to be multi-valued,
    # and puts a copy into each. Uh, call it a hidden feature.
    if ($dest) {
        my @deadmeat;
        for my $src (@tomove) {
            my $srcdata = enter($current, $src);
            add_entries($dest, $src, $srcdata);
            push @deadmeat, $src;
#            if (!map_path($current, $src, sub {
#                my ($stack, $path) = @_;
#                add_entries($dest, $path, $stack->[-1]);
#                push @deadmeat, $path;
#            })) {
#                die "Source path $src not found\n";
#                return;
#            }
        }

        # Delete backwards so array contents don't get reshuffled
        for my $victim (reverse @deadmeat) {
            delete_keys($current, $victim);
        }

        print "Moved " . @tomove . " entries\n";
    }
}

sub parse_value {
    my ($value_str) = @_;
    return $1 if $value_str =~ /^"(.*)"$/;
    return $1 if $value_str =~ /^'(.*)'$/;

    return 0 + $value_str if $value_str =~ /^\d+$/;

    # TODO: parse JSON literals or something
    return {} if $value_str eq '{}';
    return [] if  $value_str eq '[]';

    $value_str =~ s/\\(.)/$1/g;
    return $value_str;
}

sub push_value {
    my ($struct, $value) = @_;

    if (!UNIVERSAL::isa($struct, 'ARRAY')) {
        print "Cannot push; not an array\n";
        return;
    }

    push @$struct, parse_value($value);
}

sub unshift_value {
    my ($struct, $value) = @_;

    if (!UNIVERSAL::isa($struct, 'ARRAY')) {
        print "Cannot push; not an array\n";
        return;
    }

    unshift @$struct, parse_value($value);
}

sub clone {
    my ($value) = @_;
    return $value if ! ref $value;
    return $json->decode($json->encode($value));
}

sub change_element {
    my ($struct, $key, $value) = @_;
    if (UNIVERSAL::isa($struct, 'HASH')) {
        $struct->{$key} = $value;
    } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
        $struct->[$key] = $value;
    } else {
        print "At a leaf node\n";
    }
}

sub set_value {
    my ($struct, $key, $value) = @_;
    $value = parse_value($value);

    if ($key =~ m!([^/]+)/(.*)!) {
        my ($dir, $subkey) = ($1, $2);
        
        if (UNIVERSAL::isa($struct, 'HASH')) {
            if (exists $struct->{$dir}) {
                return set_value($struct->{$dir}, $subkey, $value);
            } else {
                return set_value($struct->{$dir} = {}, $subkey, $value);
            }
        } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
            if ($dir < @$struct) {
                return set_value($struct->[$dir], $subkey, $value);
            } else {
                return set_value($struct->[$dir] = {}, $subkey, $value);
            }
        } else {
            print "At a leaf node\n";
            return;
        }
    }

    if (UNIVERSAL::isa($struct, 'HASH')) {
        $struct->{$key} = $value;
        $dirty = 1;
    } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
        $struct->[$key] = $value;
        $dirty = 1;
    } else {
        print "At a leaf node\n";
    }
}

sub delete_keys {
    my ($current, $spec) = @_;

    my $dir = dirname($spec);
    $spec = basename($spec);
    map_path($current, $dir, sub {
        my ($stack, $path) = @_;
        my $struct = $stack->[-1];

        if ($spec =~ /^(\d*)\s*\.\.\s*(\d*)$/) {
            my ($from, $to) = ($1, $2);
            $from = 0 if length($from) == 0;
            $to = $#$struct if length($to) == 0;
            if ($to > $#$struct) {
                print "End of range is too high (max $#$struct)\n";
                return;
            }
            splice(@$struct, $from, $to - $from + 1);
            $dirty = 1;
            return 1;
        } else {
            if (UNIVERSAL::isa($struct, 'ARRAY')) {
                if ($spec > $#$struct) {
                    print "Index is too high (max $#$struct)\n";
                    return;
                }
                splice(@$struct, $spec, 1);
                $dirty = 1;
                return 1;
            } elsif (exists $struct->{$spec}) {
                delete $struct->{$spec};
                $dirty = 1;
                return 1;
            } else {
                print "No such key '$spec'\n";
            }
        }
    }) or print "Delete spec $spec not found\n";
}

sub joinpath {
    my ($path, $component) = @_;
    if (!defined $path) {
        return $component;
    } elsif ($path =~ /\/$/) {
        return $path . $component;
    } else {
        return "$path/$component";
    }
}

sub path_stacks {
    my ($stack, $obj, $component, $sofar, $suppress_errors, $container_only) = @_;
    # $container_only is probably still not quite right, since I think an
    # alternate group might be sometimes container-only, sometimes not

    my @stacks;
    if ($component eq '*') {
        for my $key (all_keys($obj)) {
            my $s = append($stack, $key, 'no-errors') // next;
            push @stacks, [ $s, joinpath($sofar, $key) ];
        }
    } elsif ($component eq '**' && !$container_only) {
        for my $path (all_leaf_paths($obj)) {
            my $s = appendPath($stack, $path, 'no-errors') // next;
            push @stacks, [ $s, joinpath($sofar, $path) ];
        }
    } elsif ($component eq '**' && $container_only) {
        for my $path (all_container_paths($obj)) {
            my $s = appendPath($stack, $path, 'no-errors') // next;
            push @stacks, [ $s, joinpath($sofar, $path) ];
        }
    } elsif ($component =~ /^\{(.*)\}$/) {
        my $guts = $1;
        for my $alt (split(/,/, $guts)) {
            push @stacks, path_stacks($stack, $obj, $alt, $sofar, $suppress_errors, $container_only);
        }
    } else {
        $sofar = joinpath($sofar, $component);
        if ($component eq '.' || $component eq '') {
            push @stacks, [ $stack, $sofar ];
        } elsif ($component eq '..') {
            push @stacks, [ popstack($stack), $sofar ];
        } else {
            my $s = append($stack, $component, $suppress_errors)
                or return;
            push @stacks, [ $s, $sofar ];
        }
    }

    return @stacks;
}

# Callback is invoked with (object, path). 'object' is the structure at the
# given path. It may be a leaf or a struct.
sub map_path {
    my ($stack, $path, $callback, $sofar, $suppress_errors) = @_;

    $path //= '.';

    # Absolute path
    if ($path =~ s!^/!!) {
        $stack = [ $stack->[0] ];
        $sofar = '/';
    }

    $path =~ s!/$!!;

    my $count = 0;

    # Split off the first component
    my ($first, $rest) = $path =~ m!^([^/]+)/(.*)!;

    my $obj = $stack->[-1];
    if (!defined $rest) {
        # Single component "$path"
        foreach (path_stacks($stack, $obj, $path, $sofar, $suppress_errors)) {
            my ($stack, $sofar) = @$_;
            $callback->($stack, $sofar);
            ++$count;
        }
    } else {
        # "$first/$rest"
        foreach (path_stacks($stack, $obj, $first, $sofar, $suppress_errors, 1)) {
            my ($stack, $sofar) = @$_;
            $suppress_errors ||= $first =~ /^[\*\{]/;
            $count += map_path($stack, $rest, $callback, $sofar, $suppress_errors);
        }
    }

    return $count;
}

sub popstack {
    my ($stack) = @_;
    return [ @$stack[0..$#$stack-1] ];
}

sub transform {
    my ($current, $path, $lookup) = @_;
    map_path($current, $path, sub {
        my ($stack, $path) = @_;
        if (ref $stack->[-1]) {
            print "Can only operate on simple values\n";
        } else {
            (my $new_lookup = $lookup) =~ s/\{value\}/$stack->[-1]/g;
            my @found;
            map_path($current, $new_lookup, sub {
                my ($lstack, $lpath) = @_;
                push @found, $lstack->[-1];
            });
            if (@found != 1) {
                print "LOOKUP $new_lookup resolved to no or multiple locations\n";
            } else {
                change_element($stack->[-2], $stack->[-1], clone($found[0]));
            }
        }
    });
}

sub ls {
    my ($current, $lspath) = @_;

    map_path($current, $lspath, sub {
        my ($stack, $path) = @_;
        if (num_elements($stack->[-1]) > 0) {
            unless (!defined $lspath && $path eq '.') {
                print $path;
                print "/" unless $path =~ /\/$/;
                print "\n"
            }
            my $prefix = ($path eq '.' && !defined $lspath) ? "" : "  ";
            my $stacktop = $stack->[-1];
            if (UNIVERSAL::isa($stacktop, 'ARRAY') && @$stacktop >= 8) {
                print "${prefix}indexes 0 .. $#$stacktop\n";
            } else {
                for my $key (all_keys($stacktop)) {
                    print $prefix, entry_str($stacktop, $key), "\n";
                }
            }
        } else {
            print $path, "\n";
        }
    }) or print "Path $lspath not found\n";
}

sub add_entries {
    my ($node, $path, $value) = @_;
    my $stem = basename($path);
    die "Cannot append to leaf" if ! ref $node;
    if (UNIVERSAL::isa($node, 'ARRAY')) {
        if ($stem =~ /^\d+$/) {
            push @$node, $value;
            $dirty = 1;
        } else {
            print "Cannot append named value to array\n";
        }
    } else {
        if ($stem =~ /^\d+$/) {
            # FIXME: This should really check that the parent is an array
            print "Cannot add array element to a hash\n";
        } else {
            $node->{$stem} = $value;
            $dirty = 1;
        }
    }
}

sub mv {
    my ($current, $src, $dst) = @_;
    my $dest;
    eval {
        map_path($current, $dst, sub {
            my ($stack, $path) = @_;
            if (!defined $dest) {
                if (! ref $stack->[-1]) {
                    print "$dst is a leaf, not a \"directory\"\n";
                    die "stop";
                } else {
                    $dest = $stack->[-1];
                }
            } else {
                print "$dst is not a unique directory\n";
                die "stop";
            }
        }) or print "Destination $dst not found\n";
    };

    if ($dest) {
        my @deadmeat;
        if (!map_path($current, $src, sub {
            my ($stack, $path) = @_;
            add_entries($dest, $path, $stack->[-1]);
            push @deadmeat, $path;
        })) {
            print "Source path $src not found\n";
            return;
        }

        # Delete backwards so array contents don't get reshuffled
        for my $victim (reverse @deadmeat) {
            delete_keys($current, $victim);
        }
    }
}

sub show_size {
    my ($current, $path) = @_;
    my $show_keys = defined($path);

    map_path($current, $path || '.', sub {
        my ($stack, $path) = @_;
        my $len = length($json->allow_nonref->encode($stack->[-1]));
        if ($show_keys) {
            print "$path = $len bytes\n";
        } else {
            print "$len bytes\n";
        }
    }) or print "Path $path not found\n";
}

sub cat {
    my ($current, $nokeys, $path) = @_;

    map_path($current, $path, sub {
        my ($stack, $path) = @_;
        if (num_elements($stack->[-1]) > 0) {
            print "$path/ with ", num_elements($stack->[-1]), " keys:\n";
            print $pjson->encode($stack->[-1]), "\n";
        } elsif (! ref $stack->[-1]) {
            print "$path = " unless $nokeys;
            print "$stack->[-1]\n";
        } elsif (UNIVERSAL::isa($stack->[-1], 'ARRAY')) {
            print "empty array\n";
        } else {
            print "empty hash\n";
        }
    }) or print "Path $path not found\n";
}

sub printExcess {
    my ($total, $printed) = @_;
    print "...plus " . ($total - $printed) . " more, $total total... (limit N to display more than $MAX)\n";
}

sub enter {
    my ($struct, $key, $suppress_error) = @_;
    if (UNIVERSAL::isa($struct, 'HASH')) {
        return $struct->{$key};
    } elsif (UNIVERSAL::isa($struct, 'ARRAY')) {
        if ($key !~ /^-?\d+$/) {
            print "Non-numeric key '$key' for array\n" unless $suppress_error;
            return;
        }

        return if @$struct == 0;

        # This is horrible. Handle negative indexes.
        $_[1] = ($key + @$struct) % @$struct;

        return $struct->[$key];
    } else {
        return if $suppress_error;
        print "No such key '$key'\n" unless $suppress_error;
        return;
    }
}

sub append {
    my ($stack, $key, $suppress_error) = @_;
    my $obj = enter($stack->[-1], $key, $suppress_error) // return;
    return [ @$stack, $obj ];
}

sub appendPath {
    my ($stack, $path, $suppress_error) = @_;
    for my $component (split(/\//, $path)) {
        $stack = append($stack, $component, 1) // return;
    }
    return $stack;
}

sub enterPath {
    my ($stack, $path, $suppress_errors) = @_;
    my @stack = @$stack;
    foreach (split(/\//, $path)) {
        push @stack, enter($stack[-1], $_, $suppress_errors)
            or return;
    }
    return \@stack;
}

sub num_elements {
    my ($value) = @_;

    if (UNIVERSAL::isa($value, 'HASH')) {
        return scalar(keys %$value);
    } elsif (UNIVERSAL::isa($value, 'ARRAY')) {
        return scalar(@$value);
    } else {
        return 0;
    }
}

sub chkey {
    my ($key) = @_;

    if ($key eq '.') {
        return 1;
    } elsif ($key eq '..') {
        if (@current > 1) {
            pop(@current);
            pop(@$current);
            return 1;
        } else {
            print "Already at top\n";
        }
    } else {
        my $new = enter($current->[-1], $key)
          or return;
        if (!ref($new)) {
            print "'$key' is a leaf\n";
        } else {
            push @current, $key;
            push @$current, $new;
            return 1;
        }
    }

    return;
}

sub all_keys {
    my ($value) = @_;
    if (UNIVERSAL::isa($value, 'HASH')) {
        return keys %$value;
    } elsif (UNIVERSAL::isa($value, 'ARRAY')) {
        return 0 .. $#$value;
    } else {
        return;
    }
}

# FIXME: Does not distinguish between a leaf value and an empty container
sub all_leaf_paths {
    my ($obj) = @_;
    return $obj if ! ref($obj);

    my @paths;
    for my $key (all_keys($obj)) {
        my $entry = enter($obj, $key, 'no-errors');
        if (ref($entry)) {
            for my $path (all_leaf_paths($entry)) {
                push @paths, "$key/$path";
            }
        } else {
            push @paths, $key;
        }
    }

    return @paths;
}

sub all_container_paths {
    my ($obj) = @_;
    return if ! ref($obj);

    my @paths;
    for my $key (all_keys($obj)) {
        my $entry = enter($obj, $key, 'no-errors');
        next if ! ref($entry);
        push @paths, $key;
        for my $path (all_container_paths($entry)) {
            push @paths, "$key/$path";
        }
    }

    return @paths;
}

sub chpath {
    my ($path) = @_;
    my $old_current = $current;
    my @old_current = @current;

    if ($path =~ s!^/!!) {
        $current = [ $struct ];
        splice(@current, 1);
    }

    my @pieces;
    if ($path =~ s/^'(.*)'$//) {
        @pieces = ($1);
    } else {
        @pieces = split(/\//, $path);
    }
    foreach (@pieces) {
        if (!chkey($_)) {
            $current = $old_current;
            @current = @old_current;
            print "Path component '$_' not found\n";
            return 0;
        }
    }

    return 1;
}

# This isn't exactly right, but it's kinda close
sub shortjoin {
    my $maxlen = shift;

    my (@head, @tail);
    my $left = $maxlen - 1;
    while (@_ > 0 && $left > 0) {
        if ($left > length($_[-1]) + 1) {
            unshift @tail, pop(@_);
            $left -= length($tail[-1]) + 1;
            last if @_ == 0;
            if ($left > length($_[0]) + 1) {
                push @head, shift(@_);
                $left -= length($head[-1]) + 1;
            }
        } else {
            last;
        }
    }

    if (@_ > 0) {
        push @head, "...";
    }

    return join("/", "", @head, @tail);
}

sub quit {
    if ($dirty) {
        my $input = $term->readline("Unsaved changes exist. Are you sure you want to exit (y/n)? ");
        unless ($input =~ /^y/i) {
            print "Continuing\n";
            return;
        }
    }

    exit(0);
}
