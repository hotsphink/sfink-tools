# Note: this config file contains no user-specific config.
# I put that in a separate user.toml file, and made my
# ~/.config/jj/config.toml be a directory containing
# user.toml and this file. A cleaner way would be to set
# JJ_CONFIG=$HOME/.config/jj.d and put the files there.

[fsmonitor]
#Causes random large slowdowns for me (??!)
backend = "watchman"

[ui]
#diff.format = "git"
diff-formatter = ":git"
editor = "code -w"

[snapshot]
auto-track = 'all() ~ glob:"**/*.sf.txt"'

[experimental-advance-branches]
enabled-branches = ["glob:GH.*"]

[revsets]
#log = 'ancestors(reachable(@, mutable()), 2)'
#log = 'ancestors(mutable(), 2)'
log = 'rooted_branch'

# DO NOT INCLUDE tags()! The firefox repo has >2600 tags, almost all
# of which I don't care about.
#short-prefixes = "ancestors(mutable(), 2) | bookmarks() | tags()"
short-prefixes = "ancestors(mutable(), 2) | bookmarks()"

[revset-aliases]
current = 'latest((@ & ~empty()) | @-)'
'closest_bookmark(x)' = 'heads(::x & bookmarks())'

junk = '(mutable() & empty()) ~ working_copies() ~ parents(..) ~ bookmarks()'

nmerges = 'bookmarks(glob:"G.*")'

# Topological branch
'branch(x)' = 'reachable(x, mutable())'
branch = 'branch(@)'
'rooted_branch(x)' = 'ancestors(branch(x), 2)'
rooted_branch = 'rooted_branch(@)'

'mut(s)' = 'mutable() & description(s)'

'bug(s)' = 'description("Bug ") & description(s)'
'mbug(s)' = 'mutable() & description("Bug ") & description(s)'

# These are not quite the same.
'why_immutable(r)' = '(r & immutable()) | roots(r:: & immutable_heads())'
'why_in(r, domain)' = '(r & domain) | roots(r:: & heads(domain))'

[templates]
git_push_bookmark = '"sfink/push-" ++ change_id.short()'

# Consider conner's
#git_push_bookmark = '"sfink/" ++ stringify(truncate_end(32, description.first_line().lower())).replace(regex:"[^a-zA-Z0-9]+", "-").replace(regex:"^-.*", "").replace(regex:"-*$", "") ++ "-" ++ change_id.short()'
# thomasa88 said ^-.* should be ^-* ??

draft_commit_description = '''
    concat(
    coalesce(description, "\n"),
    surround(
        "\nJJ: This commit contains the following changes:\n", "",
        indent("JJ:     ", diff.stat(72)),
    ),
    "\nJJ: ignore-rest\n",
    diff.git(),
    )
'''

[template-aliases]
brief = 'brief_line ++ "\n"'

# Removed:
#  format_short_commit_id(commit_id),

brief_line = '''
separate(" ",
  format_short_change_id_with_hidden_and_divergent_info(self),
  format_short_commit_id(commit_id),
  self.bookmarks(),
  self.tags(),
  self.working_copies(),
  if(empty, label("empty", "(no changes)")),
  if(description,
    description.first_line(),
    label(if(empty, "empty"), description_placeholder),
  ),
)
'''

'format_timestamp(timestamp)' = 'timestamp.ago()'

'hyperlink(url, text)' = '''
    concat(
      raw_escape_sequence("\e]8;;" ++ url ++ "\e\\"),
      text,
      raw_escape_sequence("\e]8;;\e\\"),
    )
'''

[aliases]

opid = ["op", "log", "-T", "id.short()", "--no-graph", "-n1"]

blame = ["file", "annotate"]

# jj bookop get <name> - show the operation id last associated with a name containing the given substring
# jj bookop get -v <name> - show all operation ids ever associated with a name containing the given substring
# jj bookop <name> - associate <name> with the current operation id
# jj bookop - show all named operation ids
# jj bookop -v - show all named operation ids (including past associations)
bookop = ["util", "exec", "--", "bash", "-c", """
    OPBOOK="$(jj git root)"/../.jj/var/operations.txt
    if [ $# -eq 0 ]; then
        sort -k2,2 -s "$OPBOOK" | tac | perl -lane 'print unless $seen{$F[1]}++' | tac
    elif [[ "$1" = "-v" ]]; then
        cat "$OPBOOK"
    elif [[ $1 = get ]]; then
        if [[ "$2" = "-v" ]]; then
            grep "$3" "$OPBOOK" | awk '{ print $1 }'
        else
            grep "$2" "$OPBOOK" | tail -1 | awk '{ print $1 }'
        fi
    else
        echo $(jj opid) "$@" >> "$OPBOOK"
    fi
""", "jj-bookop"]

info = ["log", "--no-graph"]

lg = ["log", "-T", "brief"]

lst = ["info", "-T", "brief", "-r", "(heads(ancestors(visible_heads() ~ immutable(), 2) ~ (empty() & description(exact:'')))) | nmerges- ~ present(G.deferred-)"]

current = ["info", "-r", "latest(::@ & mutable() ~ empty())", "-T", "bookmarks"]

tug = ["bookmark", "move", "--from", "closest_bookmark(@-)", "--to", "current"]

book = ["bookmark"]

pushed = ["log", "--no-graph", "-r", "pushed-", "-Tbrief"]

drop = ["abandon"]

# Rebase revset $1 and descendants, not including G.* named "marker" merges,
# onto main. This seems to magically "remove" them from the marker merges, but
# I'm not clear on why.
#
# I originally wanted this to automatically include ancestors. Or maybe
# descendants, but not marker merges. But then I realized that I might only land
# a subset of a stack, so decided that the user has to specify the exact revs. I
# do want them removed from the G.* marker merges, though. But not the unlanded
# stuff. TODO?
#
# Come to think of it... it would be good to have a simple command to take a
# parent of G.pushed and "land" it (as in, remove from G.pushed, rebase onto
# main with --skip-emptied). That means ancestors, up to...? Perhaps it would be
# (1) remove from G.pushed, (2) rebase -b <rev> -d main? I'll prototype as G.land.
landed = ["util", "exec", "--", "bash", "-x", "-c", """
    revset="(($1)::bookmarks(glob:'G.*') ~ bookmarks(glob:'G.*')) & mutable()"
    jj lg -r "$revset"
    jj rebase -d main --skip-emptied -r "$revset"
""", "jj-landed"]

# Mark a rev as awaiting review. (Add it as a parent of G.review.)
'G.review' = ["rebase", "-r", "G.review", "-d", "G.review-", "-d"]

# Move rev from G.review (if it is there) to G.pushed (regardless).
'G.push' = ["util", "exec", "--", "bash", "-e", "-c", """
    echo "Add to G.pushed"
    jj rebase -s G.pushed -d "G.pushed-" -d "$1"
    echo "Remove from G.review"
    jj rebase -s G.review -d "G.review- ~ ($1)"
""", "jj-G.push"]

# Remove and "land" a G.pushed/G.review parent.
'G.land' = ["util", "exec", "--", "bash", "-e", "-c", """
    echo "Remove from G.review"
    jj rebase -s G.review -d "G.review- ~ ($1)"
    echo "Remove from G.pushed"
    jj rebase -s G.pushed -d "G.pushed- ~ ($1)"
    echo "Rebase on main"
    jj rebase -d main --skip-emptied -b "$1"
""", "jj-G.land"]

'op@' = ["op", "log", "-n1", "--no-graph", "-T", "id.short()"]

# Use `jj amend --into xyz` to move changes from @ to xyz even when @ is one of
# my merge commits (eg G.review): don't drop the merge commit, don't try to
# squash its description into the destination.
amend = ["squash", "--keep-emptied", "--use-destination-message"]

# `jj ls X` is like `jj lg` only it shows the branch containing X instead of @.
# (just `jj ls` is the same as `jj lg`.)
ls = ["util", "exec", "--", "bash", "-c", 'jj lg -r "rooted_branch(${1:-@})"', "jj-ls"]

"show-" = ["show", "-r", "@-"]
"desc-" = ["describe", "-r", "@-"]
"diff-" = ["diff", "-r", "@-"]
"split-" = ["split", "-r", "@-"]

# Usage: jj addparent <child aka mergerev> <newparent>
#
# jj rebase -s <mergerev> -d <mergerev>- -d <newparent>
addparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s "$1" -d "$1-" -d "$2"
''', "jj-addparent"]

# Usage: jj rmparent <child aka mergerev> <oldparent>
#
# jj rebase -s <mergerev> -d "<mergerev>- ~ <oldparent>"
rmparent = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s $1 -d "$1- ~ $2"
''', "jj-rmparent"]

# Move revision $1 from (a parent of) G.review to G.pushed.
land = ["util", "exec", "--", "bash", "-c", '''
    echo "Adding to G.pushed"
    jj rebase -s G.pushed -d "G.pushed-" -d "$1"
    echo "Removing from G.review (if needed)"
    jj rebase -s G.review -d "G.review- ~ $1"
''', "jj-land"]

# Add revision $1 as a parent of G.deferred.
defer = ["util", "exec", "--", "bash", "-c", '''
    jj rebase -s G.deferred -d "G.deferred-" -d "$1"
''', "jj-defer"]

# WIP - test for subcommand aliases.
#bookmark.shove = ["bookmark", "move", "--allow-backwards"]
#shove = ["b", "--ignore-immutable", "shove", "--hard"]

# Note: for the github-review and phab-review aliases, I additionally
# alias plain "review" to the appropriate one in the repo config file.

github-review = ["util", "exec", "--", "bash", "-e", "-c", """
    REV="${1:-@}"
    CHANGE=$(jj log -G -r"$REV" -T "change_id.short()")
    export GIT_DIR=$(jj git root)
    REMOTE_COMMIT=$(git ls-remote origin "refs/heads/push-$CHANGE" | cut -f1)
    if [[ -z "$REMOTE_COMMIT" ]]; then
        echo "Unable to find push-$CHANGE branch" >&2
        ORIGIN=$(jj git remote list | grep '^origin ' | cut -d" " -f2)
        for COMMIT in $(jj evolog -G -r"$REV" -T 'commit.commit_id().short() ++ "\n"'); do
            echo Trying commit $COMMIT...
            PR=$(curl -s -H "Accept: application/json" "${ORIGIN}/branch_commits/$COMMIT" | jq '.branches[].prs[].number' | head -1)
            if [ -n "$PR" ]; then
                break
            fi
        done
    else
        PR=$(git ls-remote origin 'refs/pull/*/head' | grep "$REMOTE_COMMIT" | perl -lne 'print $1 if m!refs/pull/(\\d+)!')
    fi
    if [[ -n "$PR" ]]; then
        URL=$(jj git remote list | grep origin | cut -d" " -f2)"/pull/$PR"
        echo "Opening $URL"
        code --openExternal "$URL"
    else
        echo "Unable to find github PR URL for $REV" >&2
    fi
""", "jj-github-review"]

phab-review = ["util", "exec", "--", "bash", "-c", """
    REV="${1:-@}"
    URL=$(jj log -r"$REV" -T "description" | perl -lne 'print $1 if /Differential Revision: (https.+)/')
    if [[ -n "$URL" ]]; then
        echo "Opening $URL"
        code --openExternal "$URL"
    else
        echo "Unable to find phabricator revision URL for $REV" >&2
    fi
""", "jj-phab-review"]


# Manually fighting imports;
#  - jj log -r <base> -T 'committer.timestamp()'
#  - jj export <root> <tip> > /tmp/p
#  - cd <dest>
#  - jgit checkout -f <basecommit>
#  - jgit am -3 /tmp/p
#  - jj git import
#  - jj log -r 'mutable() & description("...")' # to figure out where it went
export = ["util", "exec", "--", "python", "-c", '''
if "indentation makes this config file more readable":
    import argparse
    import os
    import sys
    from subprocess import check_output, run, Popen, PIPE

    parser = argparse.ArgumentParser()
    parser.add_argument("first", help="First patch to export. Should not be a merge.")
    parser.add_argument("last", nargs="?", help="Last patch to export.")
    parser.add_argument("--output", "-o", metavar="FILENAME", help="write the output to this file, not valid with --import")
    parser.add_argument("--bookmark", "-b", help="bookmark to create in destination, only valid with --import")
    parser.add_argument("--stack", action='store_true', help="import immutable stack that includes `first`")
    parser.add_argument("--import", dest="destdir", nargs="?", const=os.path.expanduser("~/src/mozilla-ff/"), help="import patch(es) into repo at this path.")
    parser.add_argument("--dry-run", action='store_true', help="only display command to execute")
    args = parser.parse_args()
    os.putenv("GIT_DIR", check_output(["jj", "git", "root"]).strip())
    want_export_only = any(bool(opt) for opt in (args.output,))
    want_import = any(bool(opt) for opt in (args.destdir, args.bookmark))
    if want_import and want_export_only:
        print("both export-only and export-import options given", file=sys.stderr)
        sys.exit(1)
    def commit(rev):
        if args.dry_run:
            print(f"resolving {rev} ->", end=" ", flush=True)
            run(["jj", "--color=never", "--no-pager", "log", "--no-graph", "-r", rev, "-Tchange_id.short() ++ '\n'"], text=True)
        return check_output(["jj", "log", "--no-graph", "-r", rev, "-Tcommit_id.short(16)"], text=True)

    last = None
    if args.stack:
        first = commit(f"roots(::{args.first} & mutable())")
        last = commit(f"latest(heads({args.first}:: & mutable()))")
    elif args.last:
        first = commit(args.first)
        last = commit(args.last)
    else:
        first = commit(args.first)
        last = first
    if not args.last and not args.bookmark:
        args.bookmark = args.first
    cmd = ["git", "format-patch", "--notes", f"{first}^..{last}"]
    if args.output:
        cmd.append(f"--output={args.output}")
    else:
        cmd.append("--stdout")
    if args.dry_run:
        import shlex
        print(f"Command:\n  {shlex.join(cmd)}")
        sys.exit(0)
    if not args.destdir:
        os.execvp(cmd[0], cmd)
    process = Popen(cmd, stdout=PIPE, text=True)
    process = run(["git", "am"], stdin=process.stdout, cwd=args.destdir)
    if process.returncode != 0:
        print(f"Export to {args.destdir} failed! Aborting import (running `git am --abort`).")
        check_output(["git", "am", "--abort"], cwd=args.destdir)
    else:
        check_output(["jj", "git", "import"], cwd=args.destdir)
        check_output(["jj", "book", "create", "-r@-", args.bookmark], cwd=args.destdir)
''']

_export = ["util", "exec", "--", "bash", "-e", "-c", """
    TO_FF=0
    if [[ $1 = --ff ]]; then
      TO_FF=1
      shift
    elif [[ $1 = -o ]] || [[ $1 = --output ]]; then
      OUTPUT="--output=$2"
      shift
      shift
    else
      OUTPUT="--stdout"
    fi
    REV="${1:-@}"
    GITBASE=$(jj log --no-graph -r "roots(::$REV & mutable())" -T "commit_id")
    GITHEAD=$(jj log --no-graph -r "latest(($REV | $REV-) ~ empty())" -T "commit_id")
    if [[ $TO_FF = 0 ]]; then
      exec git format-patch $OUTPUT --notes "$GITBASE"^.."$GITHEAD"
    else
      git format-patch --stdout --notes "$GITBASE"^.."$GITHEAD" | ( cd $HOME/src/mozilla-ff; git am || git am --abort )
      echo "Tacked onto previous @"
    fi
""", "jj-export"]

# Update https://github.com/jj-vcs/jj/issues/2871#issuecomment-2864858069 with changes.
#
# "Back" button for the working directory: go back to (edit) the last (or Nth
# last) change that @ was editing, in op log order.
#
# Usage: jj back [N]
back = ["util", "exec", "--", "bash", "-c", """
    if [[ $# -gt 0 ]]; then N=$1; shift; else N=1; fi
    resolve () { jj log --no-graph -r@ -T'change_id.short() ++ "\\n"' "$@"; }
    current=$(resolve)
    jj op log --no-graph -T 'id.short() ++ "\\n"' | while read op; do
        old=$(resolve --at-op $op)
        if [[ $old != $current ]]; then
            echo -n "$N      \r"
            N=$(( $N - 1 ))
            if [[ $N -eq 0 ]]; then
                echo -n "        \r"
                if ! jj edit $old 2>/dev/null; then
                    # Handle temporary problem with evolution moving to the op log.
                    old_commit="$(jj evolog -r $old --at-op $op --no-graph -n1 -T 'commit.commit_id().short() ++ ":"')"
                    old_commit="${old_commit%%:*}"
                    echo "$old not found, trying commit $old_commit"
                    jj edit $old_commit
                fi
                exit 0
            fi
            current="$old"
        fi
    done
""", "jj-back"]

# Massively overcomplicated? Does moz-phab already do all this?
#
# https://github.com/erichdongubler-mozilla/review/pull/1
#
# moz-phab will request confirmation before doing anything, so
# there is no need for a --dry-run flag.
#
# Use `jj yeet --debug` to see the input lines being processed.
#
# Extra command line options get passed to moz-phab. This only looks
# at a linear stack of patches ending in @-
#
yeet = ["util", "exec", "--", "python", "-c", '''
if "indentation makes this config file more readable":
    import argparse
    import re
    import shlex
    import sys
    from subprocess import run, Popen, PIPE

    parser = argparse.ArgumentParser("jj yeet", description="submit a single-bug stack of patches via moz-phab", add_help=False)
    parser.add_argument("--help", "-h", action="help", help=argparse.SUPPRESS)
    parser.add_argument("--debug", "-d", action="store_true", help="log debug info")
    parser.add_argument("--bug", default=False, help="submit only revisions for given bug")
    parser.add_argument("--source", "-s", help="source revision (base of the stack to submit)")
    args, rest = parser.parse_known_args()

    if args.source:
        target = args.source
    elif rest and not rest[0].startswith("-"):
        target = rest.pop(0)
    else:
        target = "latest((@ | @-) ~ empty())"

    #run(["jj", "bookmark", "move", "-B", "moz-phab", "--to", target], check=True)

    bug = args.bug
    upstream = None
    cmd = ["jj", "log", "-r", f"::({target}) & mutable()", "-T", "commit_id.short()++' '++change_id.short(12)++' '++description.first_line()++'\n'", "--no-graph"]
    process = Popen(cmd, stdout=PIPE, text=True)
    keep = []
    earliest = None
    latest = None  # aka @-
    for line in process.stdout:
        line = line.rstrip("\r\n")
        if args.debug:
            print(f"line is <<{line}>>")
        rev, change, desc = line.split(' ', 2)
        latest = latest or change
        upstream = rev
        rev_bug = None
        if m := re.match(r'[bB]ug (\d+)', desc):
            rev_bug = m.group(1)

        # If not grabbing the first rev, and either the bug number changed or
        # we went from None (no bug) -> None, done.
        if bug is not False and ((bug != rev_bug) or (rev_bug is None)):
            break
        bug = rev_bug
        keep.append(line)
        earliest = change

    if bug is None:
        print(f"submitting rev with no bug number with upstream {upstream}")
    else:
        print(f"submitting revs for bug {bug} with upstream {upstream}")
    for line in keep:
        print(f"  {line}")

    cmd = ["moz-phab", "submit", "--upstream", upstream, earliest, latest] + rest
    print(shlex.join(["Running:"] + cmd))
    run(cmd)
''']
