#!/usr/bin/perl

# This script opens up an emacs window with the given program running
# under a debugger, all automagic-like:
#
#  - For binaries, the debugger will be gdb
#  - For perl scripts, it will be perldb
#  - For shell scripts, assume we're running firefox (yeah, nice and
#    general, huh?) and use the -g flag
#  - For cases I'm not going to document and don't currently remember, run
#    under the Effects Engine (it doesn't exist; nothing to see here.)
#
# The command given may be a regular command in $PATH, a shell alias,
# or even a shell function (of a very restricted and undocumented syntax).
#
# Yes, this script is a complete and utter hack. I've grafted on various
# bits of new functionality over time, and not in a principled way. It's
# probably only useful for my idiosyncratic ways of doing things. But I
# love it all the same, so screw off.
#
# Use --help to see a usage description.
#

use strict;
use warnings;
use File::Temp qw(tempdir);

my $TMPDIR = tempdir(CLEANUP => 1);

our $VERSION = "1.1";

my @EMACS = qw(emacs);
if ($ENV{DEBUG_EDITOR}) {
  @EMACS = $ENV{DEBUG_EDITOR} =~ /(\".*?\"|\'.*?\'|\S+)/g;
}

my $gdb = "/home/sfink/src/archer/gdb/gdb";
$gdb = "gdb" if (! -x $gdb);

my $PERL = "/usr/bin/perl";
$PERL = "perl" if (! -x $PERL);

my %opt = ( interactive => $ENV{GDB_INTERACTIVE},
            force_perl => undef,
            force_gdb => undef,
          );

$opt{interactive} = 1 if $ENV{DBG} && $ENV{DBG} eq 'wait';

# Ugh... custom arg handling because this script is supposed to be a
# transparent wrapper, and so can't use a standard getopt-ish handler.
my @local_args;
while (@ARGV && $ARGV[0] =~ /^-/) {
  local $_ = shift(@ARGV);
  if ($_ eq '-i') {
    $opt{interactive} = 1;
  } elsif ($_ eq '-p') {
    $opt{force_perl} = 1;
  } elsif ($_ eq '--notperl' || $_ eq '--gdb') {
    $opt{force_gdb} = 1;
  } elsif ($_ eq '--check') {
    $opt{pattern} = shift(@ARGV);
  } elsif (/^--check=(.*)/) {
    $opt{pattern} = $1;
  } elsif ($_ eq '--version') {
    print "Version $VERSION\n";
  } elsif ($_ eq '-h' || $_ eq '--help') {
    usage();
  } else {
    usage("unknown debug option '$_'");
  }

  push @local_args, $_;
}

if ($opt{force_perl} && $opt{force_gdb}) {
    die "You don't really know what you're doing, do you?";
}

sub usage {
  my ($msg) = @_;
  if (defined $msg) {
    select(STDERR);
    print $msg, "\n\n";
  }
  print <<'END';
Usage: debug [options] <program> args...

   -h               Display this help message
   --version        Print out the version of this script
   -i               Interactive mode; do not start running the program
   -p               Perl mode (useful when autodetection not possible)
   --notperl        Gdb mode
   --gdb            Gdb mode
   --check PATTERN  Umm... insert a startup check into emacs that kills
                    emacs if the given pattern is found in the output buffer.
                    Err... I have no memory of what this was for. Must've
                    been useful, to go to the trouble of implementing it.

Various environment variables can affect the operation. Let's see...
  $DBG :
     set to qr/EXPRESSION/ to only fire up emacs for programs
     that match the given regex. Useful when you're running
     a program that runs another program that runs the one you
     want to debug. Or, as a wholly pointless special case, if
     this is set to "wait" then it is the same as GDB_INTERACTIVE.
  $DBG_DISPLAY :
     if this is set, it will be given to gdb to use as the $DISPLAY
     for the debugger emacs window. This is to allow running the debug
     window on one display (text terminal, probably) and sending the X
     output of the debugged process to another. Currently only works for
     gdb, not perldb.
  $GDB_INITFILE :
     gdb will execute this file when it starts up.
     There are better ways of doing this, you know.
  $GDB_INITSTRING :
     execute the given gdb command at startup.
  $GDB_INTERACTIVE :
     set this to any nonempty value to have gdb
     pause before running the program. The '-i' command-line
     option does the same thing.
END
  exit defined($msg) ? 1 : 0;
}

my ($COMMAND, @args) = @ARGV;

# Allow the command to be an alias.
if ($COMMAND !~ m!/!) {
  chomp(my $which = qx!which $COMMAND 2>/dev/null!);
  if ($which =~ m!/!) {
    $COMMAND = $which;
  } else {
    open(my $fh, "$ENV{SHELL} -i -c alias |");
    while(<$fh>) {
      chomp;
      if (/^(\S+?)[=\t](.+)/) {
        my ($token, $expansion) = ($1, $2);

        # Not sure why this happens, but sometimes escape sequences
        # can get embedded in here. This isn't a very good way of getting
        # rid of them.
        $token =~ s/^\W+//;

        $expansion =~ s/^\'// && $expansion =~ s/\'$//;
        $expansion =~ s/^\"// && $expansion =~ s/\"$//;
        if ($token eq $COMMAND) {
          print "  setting COMMAND to $expansion\n";
          $COMMAND = $expansion;
          last;
        }
      }
    }
  }
}

# Or even a shell function (of a very restricted syntax)
if ($COMMAND !~ m!/!) {
  chomp(my $which = qx!$ENV{SHELL} -i -c 'whence -f $COMMAND'!);
  $which =~ s/^.*\n\s*//;
  $which =~ s/}$//;
  chomp($which);
  if ($which eq '') {
      die "$0: unable to determine what '$COMMAND' might be";
  }
  my @orig_args = @args;
  my @new_args;
  ($COMMAND, @new_args) = split(/\s+/, $which);
  @args = ();
  foreach (@new_args) {
      if ($_ eq '"$@"') {
          push @args, @orig_args;
      } else {
          push @args, $_;
      }
  }
}

# Double slashes confuse emacs because it starts over at the root
$COMMAND =~ s!/+!/!g;

chomp($ENV{CWD} = `pwd`);

# Special case for Mozilla: if the command is a shell script, then use
# -g to rerun, passing in this script as the debugger. This will only make
# sense for a Mozilla run script.
if (`file -L $COMMAND` =~ /shell script/) {
    my @debug_args;
    if (@local_args) {
        push @debug_args, "-a", join(" ", @local_args);
    }
    exec($COMMAND, "-g", "-d" => $0, @debug_args, @args);
}

# Check whether we should skip debugging this invocation
# (if DBG is set to qr/something/ that doesn't match the command line)
if ($ENV{DBG} && $ENV{DBG} =~ /qr/) {
        my $pattern = eval $ENV{DBG};
        if (join(" ", @ARGV) !~ $pattern) {
            exec(@ARGV);
        }
}

mkdir("$TMPDIR/debug-args", 0777);
unlink(glob("$TMPDIR/debug-args/*"));

# Figure out whether to run the perl debugger, and if so, massage the
# command line.
#
# Case 1: debug perl -I /tmp somescript.pl a b c
#  - COMMAND=perl somescript.pl
#  - args=a b c
# Case 2: debug somescript.pl a b c
#  - COMMAND=perl somescript.pl
#  - args=a b c
# Case 3: debug perl -I /tmp -e 'print "1\n"' a b c
#  - COMMAND=perl -e 1
#  - args=-e 'print "1\n"' a b c
# Case 4: debug -p firefox -I /tmp spot.xml
#  - COMMAND=firefox
#  - args=spot.xml
#  - FIXME
# Case 5: debug -p reactor -I /tmp -e 'print "1\n"' spot.xml
#  - COMMAND=reactor
#  - args=spot.xml
#
my $debug_perl;
if ($opt{force_gdb}) {
    # Do not treat as perl
} elsif ($COMMAND =~ /\bperl$/) {
    $debug_perl = 1;
    fix_spaces(\@args);
    my $fi = perl_upto_filename(@args);
    $COMMAND = join(" ", $COMMAND, splice(@args, 0, $fi + 1));
} elsif (`file -L $COMMAND` =~ /perl/) {
    $debug_perl = 1;
    $COMMAND = "$PERL -d $COMMAND";
} elsif ($opt{force_perl}) {
    $debug_perl = 1;
    fix_spaces(\@args);
    $COMMAND = join(" ", map { protect($_) } $COMMAND, "-d", @args);
}

sub perl_upto_filename {
  my $i = 0;
  while ($i < @_) {
    if ($_[$i] =~ /^-/) {
      if ($_[$i] =~ /^--/) {
        if ($_[$i] =~ /^--.*=/) {
          # Option value is within same argument (--foo=bar)
        } else {
          $i++; # Skip option value (--foo bar); not really correct
        }
      } else {
        if ($_[$i] =~ /^-\w*e$/) {
          # Bundle of options like -lne (or just -e)
          $i++; # Skip script
#        } elsif ($_[$i] =~ /^-.$/) {
#          $i++; # Skip argument
        } else {
          # Assume no argument or argument bundled with option eg -I/tmp
        }
      }
    } else {
      return $i;
    }
    $i++;
  }

  return @_;
}

# gud mode cannot handle args with spaces in them, so convert -e "SOME
# SCRIPT" into -e do'/tmp/xyz.pl' where /tmp/xyz.pl contains "SOME
# SCRIPT"
#
# Further bizarreness: gud is stupid and tries to convert the do'/tmp/...'
# script into an absolute path (it thinks it's the filename you're running,
# because it's the first argument that doesn't start with a dash. So prefix
# it with "-1;" just so it starts with a dash.
#
# I could do by replacing -e ... with just the filename where I wrote the
# script, but that wouldn't behave the same for
#
#   perl -e 'print ' -e '"Hello\n"'
#
# On the other hand, this doesn't work for that one either, because your
# script ends up being
#
#   -1;print-1;"Hello\n"
#
# But it works when you aren't being crazy and splitting individual lines
# up with multiple -e's.
#
# This subroutine also smushes -I /foo into -I/foo to accommodate the
# same gud brain damage.
sub fix_spaces {
  my ($array) = @_;

  my $e_ctr = 0;

  for (my $i = 0; $i < @$array; ++$i) {
    if ($array->[$i] eq '-e') {
      my $fn = "$TMPDIR/debug-args/expr-$e_ctr.pl";
      $e_ctr++;
      open(my $fh, ">", $fn) or die "Unable to write $fn: $!";
      print $fh $array->[$i+1];
      close $fh;
      $array->[$i+1] = "-1;do'$fn'";
      ++$i;
    } elsif ($array->[$i] eq '-I') {
      $array->[$i] .= $array->[$i+1];
      splice(@$array, $i + 1, 1);
    }
  }
}

sub protect {
    local $_ = shift;
    s/([\'\"\\])/\\$1/g;
    return $_;
}

if ($debug_perl) {
  my $argfile = "$TMPDIR/debug-args/perl-args-$$";
  open(ARGFILE, ">$argfile") or die "create $argfile: $!";
  print ARGFILE "$_\n" foreach (@args);
  close ARGFILE;

  exec(@EMACS, "--eval", qq[(progn (perldb "$COMMAND") (insert-string "chdir('$ENV{CWD}')") (comint-send-input) (insert-string "chomp(\@DB::ARGS=`cat $argfile`)") (comint-send-input) (insert-string "\@ARGV=\@DB::ARGS") (comint-send-input))]);
}

# From here on, we're going to use gdb
else {
  # The rx* aliases actually point to shell scripts, so grab the binary
  # out of them.
  if (`file $COMMAND` =~ /shell script/) {
    chomp($COMMAND = `$COMMAND --path`);
    die "Cannot run debug on shell scripts" if $COMMAND !~ /\w/;
    $COMMAND .= "/reactor";
  }
}

# Set the arguments
my $fname = "$TMPDIR/debug-args/c-args-$$";
open(ARGS, ">$fname") or die "create $fname: $!";
my $str = "set args ";
foreach (@args) {
  if (/'/) {
    # Problem: whatever gdb does to pass args to the shell doesn't seem
    # to handle backslashed single quotes very well.
    if (/"/) {
      # We're screwed. Just use the backslashes.
      warn "Warning: arguments contain both single- and double-quotes. I have no way of protecting them properly.\n";
      s/\'/\\\'/g;
      $str .= "'$_' ";
    } else {
      $str .= "\"$_\" ";
    }
  } else {
    s/\'/\\\'/g;
    $str .= "'$_' ";
  }
}      
chop($str) if @args;
print ARGS $str, "\n";
my $init_eval = <<"END";
 (insert-string "source $fname")
 (comint-send-input)
 (insert-string "cd $ENV{CWD}")
 (comint-send-input)
END
# (insert-string "set annotate 3")
# (comint-send-input)

if (defined $ENV{DBG_DISPLAY}) {
  my $app_display = $ENV{DISPLAY};
  $ENV{DISPLAY} = $ENV{DBG_DISPLAY};
  $init_eval .= <<"END";
 (insert-string "set env DISPLAY $app_display")
 (comint-send-input)
END
}

# If in interactive mode, bring up the gdb prompt and allow the user
# to run the program. Otherwise, run immediately.
unless ($opt{interactive}) {
    print STDERR "Running $COMMAND immediately\n";
    $init_eval .= <<"END";
 (insert-string "run")
 (comint-send-input)
END
}

# WTF was I doing here?
if ($opt{pattern}) {
  $init_eval .= <<"END";
  (beginning-of-buffer)
  (if (re-search-forward "$opt{pattern}") nil (kill-emacs))
END
# (search-buffer "$opt{pattern}" '(insert "Stopping") '(kill-emacs))
}

exec(@EMACS, "--eval", "(progn (gdb \"$gdb --annotate=3 $COMMAND\") $init_eval)");

# Copyright (c) 2002-2011 by Steve Fink. All rights reserved.
#
# You may do anything you want with this script, as long as you don't
# use it to directly or indirectly cause harm to any mythical
# creatures. Only real creatures may be harmed by the running of this
# script. Oh, and you can't remove my copyright notice either, no
# matter how much you mutate the script itself.
#
# But if you're nice, you'll properly document all the funky options, clean it
# up, and send it back to me at sphink@gmail.com. And you seem like a really
# nice person to me. (I am not; somebody actually did this once, and I
# completely ignored him. But then, he also removed the non-Perl stuff, which
# is probably a good idea -- this ought to be split into language-specific
# scripts.)
